/ *! jQuery v3.2.1 -ajax, -ajax / jsonp, -ajax / load, -ajax / parseXML, -ajax / script, -ajax / var / location, -ajax / var / nonce, -ajax / var / rquery, -ajax / xhr, -manipulation / _evalUrl, -event / ajax, -effects, -effects / Tween, -effects / animatedSelector | (c) Фонд JS и другие участники | jquery.org/license * /
! function (a, b) {"использовать строгий"; "объект" == typeof module && "object" == typeof module.exports? module.exports = a.document? b (a,! 0): function (a) {if (! a.document) выбросить новую ошибку («jQuery требует окно с документом»); return b (a)}: b (a)} («undefined»! = typeof window? window: this, function ( a, b) {"использовать строгое"; var c = [], d = a.document, e = Object.getPrototypeOf, f = c.slice, g = c.concat, h = c.push, i = c. indexOf, j = {}, k = j.toString, l = j.hasOwnProperty, m = l.toString, n = m.call (Object), o = {}; функция p (a, b) {b = b || d; var c = b.createElement ("script"); c.text = a, b.head.appendChild (c) .parentNode.removeChild (c)} var q = "3.2.1 -ajax, -ajax / JSONP, -ajax / нагрузки, -ajax / ParseXML, -ajax / скрипт, -ajax / вар / место, -ajax / вар / одноразовое значение, -ajax / вар / RQUERY, -ajax / XHR, -manipulation / _evalUrl, - событий / Ajax, -effects, -effects / твин,-effects / animatedSelector ", r = function (a, b) {вернуть новый r.fn.init (a, b)}, s = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0 ] + $ / g, t = / ^ - мс - /, u = / - ([az]) / g, v = function (a, b) {return b.toUpperCase ()}; r.fn = r. prototype = {jquery: q, конструктор: r, длина: 0, toArray: function () {return f.call (this)}, get: function (a) {return null == a? f.call (this): a <0? this [a + this.length]: this [a]}, pushStack: function (a) {var b = r.merge (this.constructor (), a); return b.prevObject = this, b }, каждый: function (a) {return r.each (this, a)}, map: function (a) {return this.pushStack (r.map (this, function (b, c) {вернуть a.call ( b, c, b)}))}, slice: function () {вернуть this.pushStack (f.apply (this, arguments))}, first: function () {вернуть this.eq (0)}, last: function () {return this.eq (-1)}, eq: function (a) {var b = this.length, c = + a + (a <0? b: 0); вернуть this.pushStack (c> = 0 && c <b? [This [c]]: [])}, end: function () {return this.prevObject || this.constructor ()}, push: h, sort: c.sort, splice: c.splice}, r.extend = r.fn.extend = function () {var a, b, c, d, e, f, g = arguments [0] || {}, h = 1, i = arguments.length, j =! 1; for ("логическое" == typeof g && (j = g, g = arguments [h] || {}, h ++), "объект" == typeof g || r.isFunction (g) || (g = {}), h === i && (g = this, h -); h <i; h ++) if ( null! = (a = arguments [h])) для (b in a) c = g [b], d = a [b], g! == d && (j && d && (r.isPlainObject (d) || (e) ? = Array.isArray (г))) (? е (е = 1, F = C && Array.isArray (с!) с: []): F = C && r.isPlainObject (с) с: {}, г [ b] = r.extend (j, f, d)): void 0! == d && (g [b] = d)); return g}, r.extend ({expando: "jQuery" + (q + Math .random ()). replace (/ \ D / g, ""), isReady:! 0, error: function (a) {throw new Error (a)}, noop: function () {}, isFunction: function ( a) {return "function" === r.type (a)}, isWindow: function (a) {return null! = a && a === a.window},isNumeric: function (a) {var b = r.type (a); return ("число" === b || "строка" === b) &&! isNaN (a-parseFloat (a))}, isPlainObject : function (a) {var b, c; return! (! a || "[объект объекта]"! == k.call (a)) && (! (b = e (a)) || (c = l.call (b, "конструктор") && b.constructor, "function" == typeof c && m.call (c) === n))}, isEmptyObject: function (a) {var b; для (b в a) return! 1; return! 0}, тип: function (a) {return null == a? a + "": "object" == typeof a || "function" == typeof a? j [k.call (a )] || "object": typeof a}, globalEval: function (a) {p (a)}, camelCase: function (a) {вернуть a.replace (t, "ms -"). replace (u, v )}, каждый: function (a, b) {var c, d = 0; if (w (a)) {for (c = a.length; d <c; d ++) if (b.call (a [d ], d, a [d]) ===! 1) break} иначе для (d в a) if (b.call (a [d], d, a [d]) ===! 1) break; return a}, отделка:function (a) {return null == a? "" :( a + ""). replace (s, "")}, makeArray: function (a, b) {var c = b || []; вернуть ноль! = a && (w (Object (a))? r.merge (c, "string" == typeof a? [a]: a): h.call (c, a)), c}, inArray: function (a , b, c) {return null == b? -1: i.call (b, a, c)}, merge: function (a, b) {for (var c = + b.length, d = 0, e = a.length; d <c; d ++) a [e ++] = b [d]; вернуть a.length = e, a}, grep: function (a, b, c) {for (var d, e = [], е = 0, г = a.length, ч = с;! е <г;! е ++), d = Ь (а [е], е), г == ч && e.push (а [е]) ; return e}, map: function (a, b, c) {var d, e, f = 0, h = []; if (w (a)) для (d = a.length; f <d; f ++ ) e = b (a [f], f, c), null! = e && h.push (e), иначе для (f in a) e = b (a [f], f, c), null! = e && h .push (e); вернуть g.apply ([], h)}, guid: 1, proxy: function (a, b) {var c, d, e; if ("string" == typeof b && (c = a [b], b = a, a = c), r.isFunction (a)) return d = f.call (arguments, 2), e = function () {return a.apply (b || this,d.concat (f.call (аргументы)))}, e.guid = a.guid = a.guid || r.guid ++, е}, теперь: Date.now, поддержка: о}), "функция" = = typeof Symbol && (r.fn [Symbol.iterator] = c [Symbol.iterator]), r.each ("Булево число Строка Функция Массив Дата Символ объекта RegExp Ошибка" .split (""), функция (a, b) {j ["[object" + b + "]"] = b.toLowerCase ()}); функция w (a) {var b = !! a && "length" в a && a.length, c = r.type (a) ; вернуть "функцию"! == c &&! r.isWindow (a) && ("массив" === c || 0 === b || "число" == typeof b && b> 0 && b-1 в a)} var x = function (a) {var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "sizzle "+ 1 * новая дата, v = a.document, w = 0, x = 0, y = ha (), z = ha (), A = ha (), B = функция (a, b) {вернуть a === б && (л =! 0), 0}, С = {}. hasOwnProperty, D = [], Е = D.pop, F = D.push G = D.push, Н = D.slice, I = функция (а,b) {for (var c = 0, d = a.length; c <d; c ++), если (a [c] === b) return c; return-1}, J = "проверено | selected | async | автофокусировка | автовоспроизведение | управления | Defer | инвалидов | скрытые | ISMAP | цикл | кратно | открыт | только для чтения | требуется | область действия», К = "[\\ x20 \\ т \\ г \\ п \\ е]", L = "(?:. \\\\ | [\\ w-] | [^ \ 0 - \\ xa0]) +", М = "\\ [" + K + "* (" + L + ") (? : "+ K +" * ([* ^ $ | ~] =?) "+ K +" * (: '((?:. \\\\ | [^ \\\\'?]) *) '| \ "((?:. \\\\ | [^ \\\\\"]) *) \ "| (" + L + ")) |)" + K + "* \\]", N = ": ( "+ L +") (: \\ ((( '((?:. \\\\ | [^ \\\\'?]) *) '| \ "((?: \\\\ |. [^ \\\\\ "]) *) \") | ((?:.. \\\\ | [^ \\\\ () [\\]] | "+ M +") *) | * ) \\) |) ", O = новый RegExp (K +" + "," g "), P = новый RegExp (" ^ "+ K +" + | ((?: ^ | [^ \\\\]) (?: \\\\.) *) "+ K +" + $ "," g "), Q = new RegExp (" ^ "+ K +" *, "+ K + "*"), R = новый RegExp ("^" + K + "* ([> + ~] |" + K + ")" + K + "*"), S = новый RegExp ("=" + K + " * ([^ \\] '\ "] *?)" + K + "* \\]", "g"), T = новый RegExp (N), U = новый RegExp ("^" + L + "$" ), V = {ID: новый RegExp ("^ # (" + L + ")"), КЛАСС: новый RegExp ("^ \\. (" + L + ")"), TAG: новый RegExp ("^ (" + L + "| [*])"), ATTR: новый RegExp ("^" + M), PSEUDO: новый RegExp ("^" + N), РЕБЕНОК: новый RegExp ("^ :( только | первый | последний | последний | энный | п-й последний) - (ребенок | из-типа) (?: \\ ( "+ K +" * (даже | нечетный | (([+ -] |) (\\ d *) п |) "+ K + "* (?: ([+ -] |)" + K + "* (\\ d +) |))" + K + "* \\) |)", "i"), bool: new RegExp ("^ ( ?: "+ J +") $ "," i "), needsContext: new RegExp (" ^ "+ K +" * [> + ~] |: (четный | нечетный | eq | gt | lt | nth | первый | последний ) (?:\\ ( "+ K +" * ((: -? \\ d) \\ d *) "+ K +" * \\) |?) (= [^ -] | $)», "я")} , W = / ^ (?: input | select | textarea | button) $ / i, X = / ^ h \ d $ / i, Y = / ^ [^ {] + \ {\ s * \ [native \ w /,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,$=/[+~]/,_=new RegExp ( "\\\\ ([\\ да-е] {1,6}" + К + "|? (" + К + ") |.)", "мкг"), аа = функция (а, б, c) {var d = "0x" + b-65536; вернуть d! == d || c? b: d <0? String.fromCharCode (d + 65536): String.fromCharCode (d >> 10 | 55296, 1023 & д | 56320)}, Ьа = / ([\ 0- \ x1f \ x7f] | ^ - \ г) |? ^ - $ | [^ \ 0- \ x1f \ x7f- \ uFFFF \ ш -] / г, ca = function (a, b) {return b? "\ 0" === a? "\ ufffd": a.slice (0, -1) + "\\" + a.charCodeAt (a.length-1) ) .toString (16) + "": "\\" + a}, da = function () {m ()}, ea = ta (function (a) {return a.disabled ===! 0 && ("form) "в ||" метка "в а)}, {dir:" parentNode ", далее:" legend "});попробовать {G.apply (D = H.call (v.childNodes), v.childNodes), D [v.childNodes.length] .nodeType} задвижка (FA) {G = {применяются: D.Length функции (а , b) {F.apply (a, H.call (b))}: function (a, b) {var c = a.length, d = 0; while (a [c ++] = b [d ++]); a.length = c-1}}} функция ga (a, b, d, e) {var f, h, j, k, l, o, r, s = b && b.ownerDocument, w = b? b.nodeType : 9; if (d = d || [], "string"! = Typeof a ||! A || 1! == w && 9! == w && 11! == w) вернуть d; if (! E && ((b ? b.ownerDocument || Ь: v) == п && м (б), B = B || п, р)) {если (== 11 && ш (л = Z.exec (а))), если (е! = l [1]) {if (9 === w) {if (! (j = b.getElementById (f))) вернуть d; if (j.id === f) вернуть d.push (j) , d} если if (s && (j = s.getElementById (f)) && t (b, j) && j.id === f) вернуть d.push (j), d} else {if (l [2]) вернуть G.apply (d, b.getElementsByTagName (a)), d; if ((f = l [3]) && c.getElementsByClassName && b.getElementsByClassName) вернуть G.apply (d, b.getElementsByClassName (f)), d} if (c.qsa &&! A [a + ""] && (! q ||! q.test (a))) {if (1! == w) s = b, r = a; else if ("object"! == b.nodeName.toLowerCase ()) {(k = b.getAttribute ("id"))? k = k.replace (ba, ca): b.setAttribute ("id ", k = u), o = g (a), h = o.length; тогда как (h -) o [h] =" # "+ k +" "+ sa (o [h]); r = o .join (","), s = $. test (a) && qa (b.parentNode) || b} if (r) try {return G.apply (d, s.querySelectorAll (r)), d} catch (x) {} finally {k === u && b.removeAttribute ("id")}}} return i (a.replace (P, "$ 1"), b, d, e)} функция ha () {var a = []; функция b (c, e) {return a.push (c + "")> d.cacheLength && delete b [a.shift ()], b [c + ""] = e} return b} функция ia (a ) {return a [u] =! 0, a} функция ja (a) {var b = n.createElement ("fieldset"); try {return !! a (b)} catch (c) {return! 1} наконец, {b.parentNode && б.parentNode.removeChild (b), b = null}} функция ka (a, b) {var c = a.split ("|"), e = c.length; while (e -) d.attrHandle [c [ e]] = b} функция la (a, b) {var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && a.sourceIndex-b.sourceIndex; if (d) возвращает d; if ( c) while (c = c.nextSibling) if (c === b) return-1; вернуть a? 1: -1} функция ma (a) {return function (b) {var c = b.nodeName.toLowerCase (); вернуть "input" === c && b.type === a}} функция na (a) {return function (b) {var c = b.nodeName.toLowerCase (); return ("input" === c || "button" === c) && b.type === a}} функция oa (a) {return function (b) {вернуть "форму" в b? b.parentNode && b.disabled ===! 1? "label" в b? "label" в b.parentNode? b.parentNode.disabled === a: b.disabled === a: b.isDisabled === a || b.isDisabled! ==! a && ea ( б) ===: с b.disabled === а: "метка"в b && b.disabled === a}} функция pa (a) {return ia (function (b) {return b = + b, ia (function (c, d) {var e, f = a ([], c) .length, б), г = f.length, тогда как (г -) с [е = е [г]] && (с [е] = (д [е] = с [е]!))})} )} функция qa (a) {вернуть && "undefined"! = typeof a.getElementsByTagName && a} c = ga.support = {}, f = ga.isXML = function (a) {var b = a && (a.ownerDocument || a) .documentElement; return !! b && "HTML"! == b.nodeName}, m = ga.setDocument = function (a) {var b, e, g = a? a.ownerDocument || a: v; return г! == п && 9 === g.nodeType && g.documentElement? (п = г, о = n.documentElement, р =! е (п), V! == п && (е = n.defaultView) && e.top! = = e && (e.addEventListener? e.addEventListener ("unload", da,! 1): e.attachEvent && e.attachEvent ("onunload", da)), c.attributes = ja (function (a) {return a.className = "я!", a.getAttribute (»className ")}), c.getElementsByTagName = ja (function (a) {return a.appendChild (n.createComment (" ")) ,! a.getElementsByTagName (" * "). length}), c.getElementsByClassName = Y .test (n.getElementsByClassName), c.getById = ja (function (a) {return o.appendChild (a) .id = u,! n.getElementsByName ||! n.getElementsByName (u) .length}), c .getById? (d.filter.ID = function (a) {var b = a.replace (_, aa); return function (a) {return a.getAttribute ("id") === b}}, d .find.ID = function (a, b) {if ("undefined"! = typeof b.getElementById && p) {var c = b.getElementById (a); вернуть c? [c]: []}}) :( d .filter.ID = function (a) {var b = a.replace (_, aa); вернуть функцию (a) {var c = "undefined"! = typeof a.getAttributeNode && a.getAttributeNode ("id"); вернуть c && c .value === b}}, d.find.ID = function (a, b) {if ("undefined"! = typeof b.getElementById &&p) {var c, d, e, f = b.getElementById (a); if (f) {if (c = f.getAttributeNode ("id"), c && c.value === a) return [f]; е = b.getElementsByName (а), д = 0, тогда как (е = е [d ++]), если (с = f.getAttributeNode ( "ID"), с && c.value === а) возвращение [е]} возвращение [ ]}}), d.find.TAG = c.getElementsByTagName? function (a, b) {return "undefined"! = typeof b.getElementsByTagName? b.getElementsByTagName (a): c.qsa? b.querySelectorAll (a) : void 0}: function (a, b) {var c, d = [], e = 0, f = b.getElementsByTagName (a); if ("*" === a) {while (c = f [ e ++]) 1 === c.nodeType && d.push (c); return d} return f}, d.find.CLASS = c.getElementsByClassName && function (a, b) {if ("undefined"! = typeof b.getElementsByClassName && p) return b.getElementsByClassName (a)}, r = [], q = [], (c.qsa = Y.test (n.querySelectorAll)) && (ja (function (a) {o.appendChild (a) .innerHTML) = "<a id = '" + u + "'> </a> <select id =' "+ u +" - \ r \\ 'msallowcapture =' '> <option selected =' '> </ option> </ select> ", a.querySelectorAll (" [msallowcapture ^ = ''] ") длина && q.push (" [* ^ $] = "+ K +" * (?: '' | \ "\"). "), a.querySelectorAll (" [выбран] ") длина || q.push ( "\\ [" + К + "* (?: значение |" + J, + ")")., a.querySelectorAll ( "[ID = ~" + и + "-]") длина || д .С ( "~ ="), a.querySelectorAll ( ": проверено") длина || q.push ( ": проверено")., a.querySelectorAll ( "а #" + и + "+ *") || длина. q.push (". #. + [+ ~]")}), ja (function (a) {a.innerHTML = "<a href='' disabled='disabled'> </a> <select disabled = 'отключено'> <опция /> </ выберите> ";var b = n.createElement ("input"); b.setAttribute ("type", "hidden"), a.appendChild (b) .setAttribute ("name", "D"), a.querySelectorAll ("[name !? = d] ") длина && q.push (" имя "+ K +" * [* ^ $ | ~] = "!), 2 == a.querySelectorAll (": включено ") длина && q.push (": включен», ": отключено"), o.appendChild (а) .disabled = 0,2 == a.querySelectorAll (! ": отключено".) длина && q.push ( ": включено", ": отключено"), a.querySelectorAll ( "* ,: х"), q.push ( "*:.")})), (c.matchesSelector = Y.test (с = o.matches || o.webkitMatchesSelector || о. mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && JA (функция (а) {c.disconnectedMatch = s.call (а, "*"), s.call (а, "[s = '']: х "), r.push ("! =», N)}), д = q.length && new RegExp (q.join ("|")), r = r.length && new RegExp (r.join ("|")), b = Y.test (o.compareDocumentPosition), t = b || Y.test ( o.contains)? function (a, b) {var c = 9 === a.nodeType? a.documentElement: a, d = b && b.parentNode; вернуть a === d ||! (! d || 1 ! == d.nodeType || (c.contains c.contains (г): a.compareDocumentPosition && 16 & a.compareDocumentPosition (г))!)}: функция (а, б) {если (б), а (б = б. parentNode) if (b === a) return! 0; return! 1}, B = b? function (a, b) {if (a === b) return l =! 0,0; var d =! a.compareDocumentPosition-! b.compareDocumentPosition; return d? d: (d = (a.ownerDocument || a) === (b.ownerDocument || b)? a.compareDocumentPosition (b): 1,1 & d ||! c.sortDetached && b.compareDocumentPosition (а) === === д а п || a.ownerDocument === v && т (V, а) - 1:? б === п || b.ownerDocument === v && т (v, б) 1: K I (к, а) -I (к, б): 0: 4 & д -1: 1)}: функция (а, б) {если (а === б) возврат l =! 0,0;var c, d = 0, e = a.parentNode, f = b.parentNode, g = [a], h = [b]; если (! e ||! f) вернуть a === n? -1: b === n? 1: e? -1: f? 1: k? I (k, a) -I (k, b): 0; если (e === f) вернуть la (a, b) ; C = A, в то время (с = c.parentNode) g.unshift (с); с = Ь, в то время (с = c.parentNode) h.unshift (с), в то время (г [d] === ч [ d]) d ++; вернуть d? la (g [d], h [d]): g [d] === v? -1: h [d] === v? 1: 0}, n): n}, ga.matches = function (a, b) {вернуть ga (a, null, null, b)}, ga.matchesSelector = function (a, b) {if ((a.ownerDocument || a)! = = n && m (a), b = b.replace (S, "= '$ 1']"), c.matchesSelector && p &&! A [b + ""] && (! r ||! r.test (b)) && (! q ||! q.test (b))) try {var d = s.call (a, b); if (d || c.disconnectedMatch || a.document && 11! == a.document.nodeType) return d } catch (e) {} return ga (b, n, null, [a]). length> 0}, ga.contains = function (a, b) {return (a.ownerDocument || a)! == n && m ! (а), т (а, б)}, ga.attr = функция (а, б) {(a.ownerDocument || а) == п && т (а);var e = d.attrHandle [b.toLowerCase ()], f = e && C.call (d.attrHandle, b.toLowerCase ())? e (a, b,! p): void 0; вернуть void 0! == F F:? c.attributes || р a.getAttribute (б) :( е = a.getAttributeNode (б)) && f.specified f.value:? нуль}, ga.escape = функция (а) {возвращение (a + ""). replace (ba, ca)}, ga.error = function (a) {throw new Error ("Синтаксическая ошибка, нераспознанное выражение:" + a)}, ga.uniqueSort = function (a) {var б, г = [], е = 0, е = 0; если (! л = c.detectDuplicates, к = c.sortStable && a.slice (0), a.sort (В), л) {в то время как (Ь = a [f ++]) b === a [f] && (e = d.push (f)); а (e -) a.splice (d [e], 1)} return k = null, a} , e = ga.getText = function (a) {var b, c = "", d = 0, f = a.nodeType; if (f) {if (1 === f || 9 === f | | 11 === f) {if ("string" == typeof a.textContent) вернуть a.textContent; for (a = a.firstChild; a; a = a.nextSibling) c + = e (a)} иначе, если (3 === f || 4 === f) вернуть a.nodeValue} else while (b = a [d ++]) c + = e (b);return c}, d = ga.selectors = {cacheLength: 50, createPseudo: ia, match: V, attrHandle: {}, найти: {}, относительный: {">": {dir: "parentNode", первый :! 0}, "": {dir: "parentNode"}, "+": {dir: "previousSibling", first:! 0}, "~": {dir: "previousSibling"}}, preFilter: {ATTR: function (a) {вернуть a [1] = a [1] .replace (_, aa), a [3] = (a [3] || a [4] || a [5] || ""). заменить (_, aa), "~ =" === a [2] && (a [3] = "" + a [3] + ""), a.slice (0,4)}, CHILD: функция (a) {вернуть a [1] = a [1] .toLowerCase (), "nth" === a [1] .slice (0,3)? (a [3] || ga.error (a [ 0]), а [4] = + (а [4] [5] + (а [6] || 1?): 2 * ( "даже" === а [3] || "нечетным" = == а [3])), а [5] = + (а [7] + а [8] || "нечетным" === а [3])): а [3] && ga.error (а [ 0]), a}, PSEUDO: function (a) {var b, c =! A [6] && a [2]; вернуть V.CHILD.test (a [0])? Null:? (А [3] [2] = а [4] || а [5] || "!": C && T.test (с) && (Ь = г (с, 0)) && (B = C. IndexOf ( ")", c.length-б) -c.length) && (а [0] = а [0] .slice (0, б), а [2] = c.slice (0, б)) , a.slice (0,3))}}, фильтр: {TAG: function (a) {var b = a.replace (_, aa) .toLowerCase (); вернуть "*" === a? function ( ) {return! 0}: function (a) {return a.nodeName && a.nodeName.toLowerCase () === b}}, CLASS: function (a) {var b = y [a + ""]; вернуть b || (b = new RegExp ("(^ |" + K + ")" + a + "(" + K + "| $)")) && y (a, function (a) {return b.test ("string" == typeof a.className && a.className || "undefined"! = typeof a.getAttribute && a.getAttribute ("class") || "")})}, ATTR: function (a, b, c) {return function (d) {var e = ga.attr (d, a); return null == e? "! =" === b:! b || (e + = "", "=" === b? e === c:=== б е == с "=!"?! "=" === б с && 0 === e.indexOf (с):? "* =" === б с && e.indexOf (с) > -1: "$ =" === b? C && e.slice (-c.length) === c: "~ =" === b? ("" + E.replace (O, "") + "") .indexOf (c)> - 1: "| =" === b && (e === c || e.slice (0, c.length + 1) === c + "-"))} }, РЕБЕНОК: функция (a, b, c, d, e) {var f = "nth"! == a.slice (0,3), g = "last"! == a.slice (-4) , h = "типа" === b; return 1 === d && 0 === e? function (a) {return !! a.parentNode}: function (b, c, i) {var j, k !, л, м, н, о, п = е == г "NextSibling":?! "PreviousSibling", д = b.parentNode, R = H && b.nodeName.toLowerCase (), S = I && ч, т = ! 1, если (Q) {если (е) {в то время как (р) {т = б, в то время (т = т [р]), если (ч m.nodeName.toLowerCase () === г: 1 == = m.nodeType) возвращение 1;! о = р = "только" === && && о»!NextSibling "}} возвращает 0, если! (о = [г q.firstChild: q.lastChild], г && ы) {т = д, л = т [и] || (т [и] = {}), K = л [m.uniqueID] || (л [m.uniqueID] = {}), J = к [а] || [], п ​​= у [0] === ш && J [1], т = п && J [2 ], т = п && q.childNodes [п], в то время (т = п ++ && && м м [р] || (т = п = 0) || o.pop ()), если (1 === m.nodeType && ++, т && м === b) {k [a] = [w, n, t]; перерыв}} иначе, если (s && (m = b, l = m [u] || (m [u] = {}), k = л [m.uniqueID] || (л [m.uniqueID] = {}), J = к [а] || [], п ​​= у [0] === ш && J [1], т = п) , т ===! 1), а (т = п ++ && && м м [р] || (т = п = 0) || o.pop ()), если ((ч? m.nodeName.toLowerCase () === г: 1 === m.nodeType) && ++, т && (ы && (л = т [и] || (м [и] = {}), к = л [m.uniqueID] || (л [м. uniqueID] = {}), k [a] = [w, t]), m === b)) break; вернуть t- = e, t === d || t% d === 0 && t / d > = 0}}}, PSEUDO: function (a, b) {var c, e = d.pseudos [a] || d.setFilters [a.toLowerCase ()] || ga.error ("неподдерживаемое псевдо:" + а);return e [u]? e (b): длина e> 1? (c = [a, a, "", b], d.setFilters.hasOwnProperty (a.toLowerCase ())? ia (function (a, c) {var d, f = e (a, b), g = f.length; тогда как (g -) d = I (a, f [g]), a [d] =! (c [d] = f [g])}): function (a) {return e (a, 0, c)}): e}}, псевдо: {not: ia (function (a) {var b = [], c = [], d = h (a.replace (P, "$ 1")); return d [u]? ia (функция (a, b, c, e) {var f, g = d (a, null, e , []), Н = a.length, в то время (ч -) (F = G [H]) && (а [ч] = (B [H] = F!))}): функции (а, е , f) {return b [0] = a, d (b, null, f, c), b [0] = null,! c.pop ()}}), имеет: ia (function (a) {return function (b) {return ga (a, b) .length> 0}}), содержит: ia (function (a) {return a = a.replace (_, aa), function (b) {return (b. textContent || b.innerText || e (b)). indexOf (a)> - 1}}), lang: ia (function (a) {return U.test (a || "") || ga.error ("неподдерживаемый lang:" + a), a = a.replace (_, aa) .toLowerCase (), function (b) {var c; do if (c = p? b.lang: b.getAttribute ("xml) :lang ") || b.getAttribute (" lang ")) return c = c.toLowerCase (), c === a || 0 === c.indexOf (a +" - "); while ((b = b .parentNode) && 1 === b.nodeType); return! 1}}), target: function (b) {var c = a.location && a.location.hash; вернуть c && c.slice (1) === b.id }, root: function (a) {return a === o}, focus: function (a) {return a === n.activeElement && (! n.hasFocus || n.hasFocus ()) && !! (a .type || a.href || ~ a.tabIndex)}, включено: oa (! 1), отключено: oa (! 0), проверено: function (a) {var b = a.nodeName.toLowerCase (); вернуть «input» === b && !! a.checked || «option» === b && !! a.selected}, selected: function (a) {вернуть a.parentNode && a.parentNode.selectedIndex, a.selected == ! = 0}, пусто: функция (а) {для (а = a.firstChild; а; а = a.nextSibling), если (a.nodeType <6) возвращение 1; возврат 0}, родитель:! (а функции ) {! возврат d.pseudos.empty (а)}, заголовок:function (a) {return X.test (a.nodeName)}, вход: function (a) {return W.test (a.nodeName)}, кнопка: function (a) {var b = a.nodeName.toLowerCase ( ); вернуть «input» === b && «button» === a.type || «button» === b}, текст: function (a) {var b; вернуть «input» === a.nodeName .toLowerCase () && "текст" === a.type && (нуль == (б = a.getAttribute ( "тип")) || "текст" === b.toLowerCase ())}, во-первых: ра ( функция () {возвращение [0]}), последнее: ра (функция (а, б) {возвращение [B-1]}), экв: ра (функция (а, б, в) {возвращение [с <0? c + b: c]}), четное: pa (function (a, b) {for (var c = 0; c <b; c + = 2) a.push (c); вернуть a}), нечетное: pa (function (a, b) {for (var c = 1; c <b; c + = 2) a.push (c); вернуть a}), lt: pa (function (a, b, c) {for ( var d = c <0? c + b: c; - d> = 0;) a.push (d); return a}), gt: pa (function (a, b, c) {for (var d = c <0? c + b: c; ++ d <b;) a.push (d); вернуть a})}}, d.pseudos.nth = d.pseudos.eq;для (b в {radio:! 0, флажок:! 0, файл:! 0, пароль:! 0, изображение:! 0}) d.pseudos [b] = ma (b); для (b в {submit: ! 0, сброс:! 0}) d.pseudos [b] = na (b); функция ra () {} ra.prototype = d.filters = d.pseudos, d.setFilters = new ra, g = ga. tokenize = function (a, b) {var c, e, f, g, h, i, j, k = z [a + ""]; если (k) вернуть b? 0: k.slice (0); h ! = а, я = [], J = d.preFilter, в то время (ч) {с && (е = Q.exec (з)) || (е && (ч = h.slice (е [0] .length) | ! | ч), i.push (е = [])), с = 1, (е = R.exec (ч)) && (с = e.shift (), f.push ({значение: C, тип : e [0] .replace (P, "")}), h = h.slice (c.length)); для (g в d.filter)! (e = V [g] .exec (h)) || J [г] && (е = у [г] (е)) || (с = e.shift (), f.push (! {значение: C, типа: г, совпадения: е}), ч = h.slice (c.length)); if (! c) break} return b? h.length: h? ga.error (a): z (a, i) .slice (0)}; функция sa ( a) {for (var b = 0, c = a.length, d = ""; b <c; b ++) d + = a [b] .value; вернуть d} функция ta (a, b, c) {var д = b.dir, е = b.next, е = е || д, г = с &&"parentNode" === f, h = x ++; вернуть функцию b.first? (b, c, e) {while (b = b [d]), если (1 === b.nodeType || g) вернуть a (b, c, e); return! 1}: функция (b, c, i) {var j, k, l, m = [w, h]; if (i) {while (b = b [d] ) if ((1 === b.nodeType || g) && a (b, c, i)) возвращает! 0}, в то время как (b = b [d]) if (1 === b.nodeType || g ), если (л = Ь [и] || (Ь [и] = {}), к = л [b.uniqueID] || (л [b.uniqueID] = {}), е && е === b.nodeName .toLowerCase ()) b = b [d] || b; else {if ((j = k [f]) ​​&& j [0] === w && j [1] === h) вернуть m [2] = j [2]; если (k [f] = m, m [2] = a (b, c, i)) return! 0} return! 1}} function ua (a) {return a.length> 1? Function (b, c, d) {var e = a.length; while (e -) if (! a [e] (b, c, d)) возвращает! 1; возвращает! 0}: a [0]} функция va (a, b, c) {для (var d = 0, e = b.length; d <e; d ++) ga (a, b [d], c); return c} функция wa (a, b , c, d, e) {для (var f, g = [], h = 0, i = длина a, j = ноль! = b; h <i; h ++) (f = a [h]) && (c &&! c (f, d, e) || (g.push (f), j && b.push (h))); вернуть функцию g} xa (a, b, c, d, e,f) {вернуть d &&! d [u] && (d = xa (d)), e &&! e [u] && (e = xa (e, f)), ia (функция (f, g, h, i) {var j, k, l, m = [], n = [], o = длина g, p = f || va (b || "*", h.nodeType? [h]: h, [] !!), д = а || е р && б: в (р, м, а, H, I), г = с й || (е: с? о || г) []: г: д ; если (с && с (д, г, д, г), д) {J = ва (г, п), д (J, [], H, I), к = j.length, в то время (k--) (л = у [к]) && (г [п [K]]! = (д [п [K]] = л))}, если (е) {если (е || а) {если (е) { J = [], к = r.length, в то время (к -) (л = г [к]) && j.push (д [к] = л); е (нуль, г = [], J, I) } к = r.length, в то время (к -) (л = г [к]) && (J = е I (F, л): м [к])!> - 1 && (F [J] = ( g [j] = l))}} иначе r = wa (r === g? r.splice (o, r.length): r), e? e (null, g, r, i): G. apply (g, r)})} функция ya (a) {для (var b, c, e, f = a.length, g = d.relative [a [0] .type], h = g || d .relative [""], i = g? 1: 0, k = ta (function (a) {return a === b}, h,! 0), l = ta (function (a) {return I ( b, a)> - 1}, h,! 0), m = [function (a, c, d) {var e =! g && (d || c! == j) || ((b = c) ,nodeType? k (a, c, d): l (a, c, d)); return b = null, e}]; i <f; i ++) if (c = d.relative [a [i] .type ]) т = [та (иа (м), с)], иначе {если (с = d.filter [а [я] .type] .Нанесите (нуль, а [я] .matches), с [и] ) {for (e = ++ i; e <f; e ++) if (d.relative [a [e] .type]) break; вернуть xa (i> 1 && ua (m), i> 1 && sa (a.slice ( 0, i-1) .concat ({value: "" === a [i-2] .type? "*": ""})). Replace (P, "$ 1"), c, i <e && ya (a.slice (i, e)), e <f && ya (a = a.slice (e)), e <f && sa (a))} m.push (c)} return ua (m)} функция za (a , b) {var c = b.length> 0, e = a.length> 0, f = функция (f, g, h, i, k) {var l, o, q, r = 0, s = " 0" , т = е && [], и = [], v = у, х = е || е && d.find.TAG ( "*", к), у = W + = NULL == v 1: Math.random () || 0,1, г = x.length, ибо (к && (J = г === п || г || л);! s == г && нуль = (л = х [с]), s ++) {если (е && л) {о = 0, г || l.ownerDocument === п || (м (л), ч = р!), тогда как (д = а [о ++]), если (д (л, г || п,з)) {i.push (л); перерыв} к && (ш = у)} с && ((л = д && л) && г -, F && t.push (L))}, если (R + = S, C && s ==! г) {о = 0, тогда (д = б [о ++]) д (т, и, г, д); если (е) {если (г> 0), а (с -) т [с] || и [с] || (и [с] = E.call (я));! и = ва (и)} G.apply (я, и), к && е && u.length> 0 && г + b.length> 1 && га. uniqueSort (i)} return k && (w = y, j = v), t}; return c? ia (f): f} return h = ga.compile = function (a, b) {var c, d = [ ], e = [], f = A [a + ""]; if (! f) {b || (b = g (a)), c = b.length; тогда как (c -) f = ya ( b [c]), f [u]? d.push (f): e.push (f); f = A (a, za (e, d)), f.selector = a} return f}, i = ga.select = function (a, b, c, e) {var f, i, j, k, l, m = "function" == typeof a && a, n =! e && g (a = m.selector || a ); если (C = C || [], 1 === n.length) {если (я = п [0] = п [0] .slice (0), i.length> 2 && "ИД" == = (J = я [0]). тип && 9 === b.nodeType && && р d.relative [I [1] .Type]) {если (Ь = (d.find.ID (j.matches [0] .replace (_, aa), b) || []) [0] ,! b) return c; m && (b = b.parentNode), a = a.slice (i. . сдвиг () value.length)} F = V.needsContext.test (а) 0: i.length, в то время (е -) {если (J = я [F], d.relative [к = J?. тип]) перерыва, если ((L = d.find [K]) && (е = л (j.matches [0] .Надеть (_, аа), $ тест (я [0] .type) && QA (. b.parentNode) || b))) {if (i.splice (f, 1), a = e.length && sa (i) ,! a) вернуть G.apply (c, e), c; break}}} возвращение (м || ч (а, п)) (е, б,! р, с,! Ь || $ .test (а) && QA (b.parentNode) || б), с}, c.sortStable = u.split (""). sort (B) .join ("") === u, c.detectDuplicates = !! l, m (), c.sortDetached = ja (function (a) {return 1 & a.compareDocumentPosition (n.createElement ("fieldset"))}), ja (function (a) {return a.innerHTML = "<a href='#'> </a>", "#" === a.firstChild. GetAttribute ( "HREF")}) || ка ( "тип | HREF | высота | ширина", функция (а, б,c) {if (! c) вернуть a.getAttribute (b, "type" === b.toLowerCase ()? 1: 2)}), c.attributes && ja (function (a) {return a.innerHTML = "< ввод />», a.firstChild.setAttribute ( "значение", "") "" === a.firstChild.getAttribute ( "значение")}) || ка ( "значение", функция (а, б, c) {if (! c && "input" === a.nodeName.toLowerCase ()) вернуть a.defaultValue}), ja (function (a) {return null == a.getAttribute ("disabled")})) | | ka (J, функция (a, b, c) {var d; if (! c) возвращает a [b] ===! 0? b.toLowerCase () :( d = a.getAttributeNode (b)) && d ? .specified d.value: NULL}), га} (а); r.find = х, r.expr = x.selectors, r.expr [ ":"] = r.expr.pseudos, r.uniqueSort = r.unique = x.uniqueSort, r.text = x.getText, r.isXMLDoc = x.isXML, r.contains = x.contains, r.escapeSelector = x.escape; var y = функция (a, b, c ) {var d = [], e = void 0! == c; while ((a = a [b]) && 9!== a.nodeType) if (1 === a.nodeType) {if (e && r (a) .is (c)) break; d.push (a)} return d}, z = function (a, b) {for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a! == b && c.push (a); return c}, A = r.expr.match.needsContext; функция B (a, b) {вернуть a.nodeName && a.nodeName.toLowerCase () === b.toLowerCase ()} var C = / ^ <([az] [^ \ / \ 0>: \ x20 \ t \ r \ п \ е] *) [\ x20 \ т \ г \ п \ е] * \ /> (<\ / \ 1> |) $ / я, D = / ^ [^:?. # \ [\ .,] * $ /; function E (a, b, c) {return r.isFunction (b)? r.grep (a, function (a, d) {return !! b.call (a, d, a )! == c}): b.nodeType? r.grep (a, function (a) {return a === b! == c}): "строка"! = typeof b? r.grep (a, function (a) {return i.call (b, a)> - 1! == c}): D.test (b)? r.filter (b, a, c) :( b = r.filter (b , a), r.grep (a, function (a) {return i.call (b, a)> - 1! == c && 1 === a.nodeType}))} r.filter = function (a, b , c) {var d = b [0]; вернуть c && (a = ": not (" + a + ")"), 1 === b.length && 1 === d.nodeType? r.find.matchesSelector (d, a)? [d]: []: r.find.matches (a, r.grep (b, function (a) {return 1 ===) a.nodeType}))}, r.fn.extend ({find: function (a) {var b, c, d = this.length, e = this; if ("string"! = typeof a) возвращает this. pushStack (г (а) .filter (функция () {для (Ь = 0, б <D, B ++), если (r.contains (е [B], это)) возврат 0!})), для (с = this.pushStack ([]), b = 0; b <d; b ++) r.find (a, e [b], c); возврат d> 1? r.uniqueSort (c): c}, filter: function (a) {вернуть this.pushStack (E (this, a || [] ,! 1))}, а не: function (a) {вернуть this.pushStack (E (this, a || [] ,! 0) )}: is: function (a) {return !! E (this, "string" == typeof a && A.test (a)? r (a): a || [] ,! 1) .length}}); var F, G = / ^ (?: \ s * (<[\ w \ W] +>) [^>] * | # ([\ w -] +)) $ /, H = r.fn.init = function (a, b, c) {var e, f; if (! a) вернуть это; if (c = c || F, "string" == typeof a) {if (e = "<" == = а [0] && ">" === а [a.length-1] && A.length> = 3 [нуль, а, нуль]:?!? G.exec (а) ,! е || е [1] && б) возвращение Ь || b.jquery (б || с) .find (a): this.constructor (b) .find (a); if (e [1]) {if (b = b instanceof r? b [0]: b, r.merge (this, r.parseHTML (e) [1], b && b.nodeType? B.ownerDocument || b: d,! 0)), C.test (e [1]) && r.isPlainObject (b)) для (e in b) r.isFunction (this [ e])? this [e] (b [e]): this.attr (e, b [e]); вернуть this} return f = d.getElementById (e [2]), f && (this [0] = f, this.length = 1), this} возвращает a.nodeType? (this [0] = a, this.length = 1, this): r.isFunction (a)? void 0! == c.ready? c .ready (a): a (r): r.makeArray (a, this)}; H.prototype = r.fn, F = r (d); var I = / ^ (?: parent | prev (?: До | Все)) /, J = {children:! 0, содержимое:! 0, следующее:! 0, prev:! 0}; r.fn.extend ({has: function (a) {var b = r ( a, this), c = b.length; вернуть this.filter (function () {for (var a = 0; a <c; a ++), если (r.contains (this, b [a]))) вернуть! 0 })}, ближайший: function (a, b) {var c, d = 0, e = this.length, f = [],g = "строка"! = typeof a && r (a); if (! A.test (a)) для (; d <e; d ++) для (c = this [d]; c && c! == b; c = c .parentNode), если (c.nodeType <11 && (г g.index (с)?> - 1: 1 === c.nodeType && r.find.matchesSelector (с, а))) {f.push (с); перерыв } return this.pushStack (f.length> 1? r.uniqueSort (f): f)}, index: function (a) {return a? "string" == typeof a? i.call (r (a), это [0]): i.call (это, a.jquery а [0]: а): это [0] && это .parentNode this.first () возобладать () длина [0]:?.. -1} , add: function (a, b) {вернуть this.pushStack (r.uniqueSort (r.merge (this.get (), r (a, b))))}, addBack: function (a) {вернуть это. add (null == a? this.prevObject: this.prevObject.filter (a))}}); функция K (a, b) {while ((a = a [b]) && 1! == a.nodeType) ; return a} r.each ({parent: function (a) {var b = a.parentNode; return b && 11! == b.nodeType? b: null}, родители: function (a) {return y (a, ") ParentNode ")},parentUntil: function (a, b, c) {return y (a, "parentNode", c)}, далее: function (a) {return K (a, "nextSibling")}, prev: function (a) {return K (a, "previousSibling")}, nextAll: function (a) {return y (a, "nextSibling")}, prevAll: function (a) {return y (a, "previousSibling")}, nextUntil: function ( a, b, c) {return y (a, "nextSibling", c)}, prevUntil: function (a, b, c) {return y (a, "previousSibling", c)}, братья и сестры: функция (a) {return z ((a.parentNode || {}). firstChild, a)}, children: function (a) {return z (a.firstChild)}, содержимое: function (a) {return B (a, "iframe ") a.contentDocument: (В (а," шаблон ") && (а = a.content || а), r.merge ([], a.childNodes))}}, функция (а, б) { r.fn [a] = function (c, d) {var e = r.map (this, b, c); вернуть «До»! == a.slice (-5) && (d = c), d && "строка" == typeof d && (e = r.фильтр (д, е)), this.length> 1 && (J [а] || r.uniqueSort (е), I.test (а) && e.reverse ()), this.pushStack (е)}}); var L = / [^ \ x20 \ t \ r \ n \ f] + / g; функция M (a) {var b = {}; вернуть r.each (a.match (L) || [], функция (a, c) {b [c] =! 0}), b} r.Callbacks = function (a) {a = "строка" == тип a? M (a): r.extend ({}, a ); var b, c, d, e, f = [], g = [], h = -1, i = function () {для (e = e || a.once, d = b =! 0; g.length; ч = -1) {с = g.shift (!), в то время как (++ H <f.length) П [ч] .Нанесите (с [0], с [1]) === 1 && ! .stopOnFalse && (! ч = f.length, с = 1)} a.memory || (! с = 1), б = 1, е && (F = C []:? "")}, J = {добавить : function () {return f && (c &&! b && (h = f.length-1, g.push (c)), function d (b) {r.each (b, function (b, c) {r.isFunction (с) a.unique && j.has (с) || f.push (с): с && c.length && "строка" == r.type (с) && d (с)})} (аргументы), с && && б я! ()), это}, удалить:function () {return r.each (arguments, function (a, b) {var c; while ((c = r.inArray (b, f, c))> - 1) f.splice (c, 1), c <= h && h -}), это}, имеет: function (a) {return a? r.inArray (a, f)> - 1: f.length> 0}, пусто: function () {return f && ( f = []), это}, отключить: function () {return e = g = [], f = c = "", это}, отключено: function () {return! f}, lock: function () { return e = g = [], c || b || (f = c = ""), this}, locked: function () {return !! e}, fireWith: function (a, c) {return e | | (C = C || [], с = [а, c.slice c.slice ():? с], g.push (с), б || я ()), это}, огонь: функция ( ) {return j.fireWith (this, arguments), this}, запущено: function () {return !! d}}; return j}; function N (a) {return a} функция O (a) {throw a} function P (a, b, c, d) {var e; try {a && r.isFunction (e = a.promise)? e.call (a) .done (b) .fail (c): a && r.isFunction (e = a.then)? e.call (a, b, c): b.apply (void 0, [a] .slice (d))} catch (a) {c.apply (void 0, [a]) }}р.extend ({Deferred: function (b) {var c = [["notify", "progress", r.Callbacks ("memory"), r.Callbacks ("memory"), 2], ["resolve", " done ", r.Callbacks (" Once memory "), r.Callbacks (" Once memory "), 0," resolved "], [" reject "," fail ", r.Callbacks (" Once memory "), r .Callbacks ("Once memory"), 1, "rejected"]], d = "pending", e = {state: function () {return d}, всегда: function () {return f.done (arguments). fail (arguments), это}, "catch": function (a) {return e.then (null, a)}, pipe: function () {var a = arguments; return r.Deferred (function (b) {r) .each (c, function (c, d) {var e = r.isFunction (a [d [4]]) && a [d [4]]; f [d [1]] (function () {var a = е && e.apply (это, аргументы); && r.isFunction (a.promise) a.promise () прогресс (b.notify) .done (b.resolve)?..Сбой (b.reject): б [д [0] + "С"] (это, е [а]: аргументы)})}), а = NULL}) обещание ()}, то:. Функция (б , d, e) {var f = 0; функция g (b, c, d, e) {return function () {var h = this, i = аргументы, j = function () {var a, j; if ( ! (b <f)) {if (a = d.apply (h, i), a === c.promise ()) выбрасывает новый TypeError ("возможное разрешение"), j = a && ("object" == typeof a || "function" == typeof a) && a.then, r.isFunction (j)? e? j.call (a, g (f, c, N, e), g (f, c, О, е)) :( е ++ j.call (а, г (F, C, N, E), G (F, C, O, е), G (F, C, N, c.notifyWith)) ) :( d! == N && (h = void 0, i = [a]), (e || c.resolveWith) (h, i))}}, k = e? j: function () {try { j ()} catch (a) {r.Deferred.exceptionHook && r.Deferred.exceptionHook (a, k.stackTrace), b + 1> = f && (d! == O && (h = void 0, i = [a]) , c.rejectWith (h, i))}}; b? k () :( r.Deferred.getStackHook && (k.stackTrace = r.Deferred.getStackHook ()), a.setTimeout (k))}} return r ,Отложенный (функция (а) {с [0] [3] .add (г (0, а, r.isFunction (е) е: N, a.notifyWith)), с [1] [3] .add ( г (0, а, r.isFunction (б) б:? Н)), в [2] [3] .add (г (0, а, r.isFunction (д) д: О))}). обещание ()}, обещание: функция (а) {вернуть ноль! = a? r.extend (a, e): e}}, f = {}; вернуть r.each (c, function (a, b) { var g = b [2], h = b [5]; e [b [1]] = g.add, h && g.add (function () {d = h}, c [3-a] [2]. отключить, c [0] [2] .lock), g.add (b [3] .fire), f [b [0]] = function () {return f [b [0] + "With"] ( this === f? void 0: this, аргументы), this}, f [b [0] + "With"] = g.fireWith}), e.promise (f), b && b.call (f, f) , f}, когда: function (a) {var b = arguments.length, c = b, d = Array (c), e = f.call (arguments), g = r.Deferred (), h = function ( a) {return function (c) {d [a] = this, e [a] = arguments.length> 1? f.call (arguments): c, - b || g.resolveWith (d, e)} };.!, если (б <= 1 && (Р (а, g.done (ч (с)) решимость, g.reject, б), "до" === g.state () || r.isFunction ( е [с] &&e [c] .then))) возвращает g.then (), а (c -) P (e [c], h (c), g.reject); возвращает g.promise ()}}); var Q = / ^ (Eval | Внутренний | Диапазон | Ссылка | Синтаксис | Тип | URI) Ошибка $ /; r.Deferred.exceptionHook = функция (Ь, с) {a.console && && a.console.warn б && Q.test (b.name) && a.console.warn ("исключение jQuery.Deferred:" + b.message, b.stack, c)}, r.readyException = function (b) {a.setTimeout (function () {throw b})}; var R = r.Deferred (); r.fn.ready = function (a) {return R.then (a) ["catch"] (function (a) {r.readyException (a);readyException = function (b) {a.setTimeout (function () {throw b})}; var R = r.Deferred (); r.fn.ready = function (a) {return R.then (a) [" поймать "] (функция (а) {r.readyException (а);readyException = function (b) {a.setTimeout (function () {throw b})}; var R = r.Deferred (); r.fn.ready = function (a) {return R.then (a) [" поймать "] (функция (а) {r.readyException (а);
}), Это}, r.extend ({isReady: 1, readyWait: 1, готов: функция (а) {(а === 0 - r.readyWait:? R.isReady) || (г. isReady =! 0, a! ==! 0 && - r.readyWait> 0 || R.resolveWith (d, [r]))}}), r.ready.then = R.then; function S () { d.removeEventListener ( "DOMContentLoaded", S), a.removeEventListener ( "нагрузка", S), r.ready ()} "полный" === d.readyState || "загрузка"! == d.readyState &&! д .documentElement.doScroll? a.setTimeout (r.ready) :( d.addEventListener ("DOMContentLoaded", S), a.addEventListener ("load", S)); var T = функция (a, b, c, d , e, f, g) {var h = 0, i = a.length, j = null == c; if ("object" === r.type (c)) {e =! 0; для (h в в) T (a, b, h, c [h] ,! 0, f, g)} иначе, если (void 0! == d && (e =! 0, r.isFunction (d) || (g = ! 0), j && (g? (B.call (a, d), b = null) :( j = b, b = function (a, b, c) {вернуть j.call (r (a), c )})), б)) для (; ч <я; ч ++), Ь (а [ч], с, г д: d.call (а [ч], ч, б (а [ч],c))); вернуть e? a: j? b.call (a): i? b (a [0], c): f}, U = function (a) {return 1 === a.nodeType | | 9 === a.nodeType ||! + A.nodeType}; функция V () {this.expando = r.expando + V.uid ++} V.uid = 1, V.prototype = {cache: function (a ) {var b = a [this.expando]; вернуть b || (b = {}, U (a) && (a.nodeType? a [this.expando] = b: Object.defineProperty (a, this.expando) , {значение: b, настраивается:! 0}))), b}, set: function (a, b, c) {var d, e = this.cache (a); if ("string" == typeof b ) e [r.camelCase (b)] = c; еще для (d в b) e [r.camelCase (d)] = b [d]; return e}, get: function (a, b) {return void 0 === b? This.cache (a): a [this.expando] && a [this.expando] [r.camelCase (b)]}, доступ: функция (a, b, c) {return void 0 = == b || b && "string" == typeof b && void 0 === c? this.get (a, b) :( this.set (a, b, c), void 0! == c? c: b )}, удалить: function (a, b) {var c, d = a [this.expando]; if (void 0! == d) {if (void 0! == b) {Array.isArray (b) ? б = b.map (r.camelCase):(b = r.camelCase (b), b = b в d? [b]: b.match (L) || []), c = b.length; в то время как (c -) удалить d [b [c ]]} (void 0 === b || r.isEmptyObject (d)) && (a.nodeType? a [this.expando] = void 0: удалить [this.expando])}}, hasData: function ( a) {var b = a [this.expando]; вернуть void 0! == b &&! r.isEmptyObject (b)}}; var W = new V, X = new V, Y = / ^ (?: \ { [\ w \ W] * \} | \ [[\ w \ W] * \]) $ /, Z = / [AZ] / g; функция $ (a) {return "true" === a || "false"! == a && ("null" === a? null: a === + a + ""? + a: Y.test (a)? JSON.parse (a): a)} function _ ( a, b, c) {var d; if (void 0 === c && 1 === a.nodeType) if (d = "data -" + b.replace (Z, "- $ &"). toLowerCase () , c = a.getAttribute (d), "string" == typeof c) {try {c = $ (c)} catch (e) {} X.set (a, b, c)} else c = void 0 ; return c} r.extend ({hasData: function (a) {return X.hasData (a) || W.hasData (a)}, data: function (a, b, c) {return X.access (a , б, в)}, removeData:function (a, b) {X.remove (a, b)}, _ данные: функция (a, b, c) {вернуть W.access (a, b, c)}, _ removeData: function (a, b) { W.remove (a, b)}}), r.fn.extend ({data: function (a, b) {var c, d, e, f = this [0], g = f && f.attributes; if ( void 0 === a) {if (this.length && (e = X.get (f), 1 === f.nodeType &&! W.get (f, "hasDataAttrs"))) {c = g.length; в то время как (с -) г [с] && (г = г [с] .name, 0 === d.indexOf ( "данные -") && (д = r.camelCase (d.slice (5)), _ (f, d, e [d]))); W.set (f, "hasDataAttrs",! 0)} return e} return "object" == typeof a? this.each (function () {X. set (this, a)}): T (this, function (b) {var c; if (f && void 0 === b) {if (c = X.get (f, a), void 0! == c ) return c; if (c = _ (f, a), void 0! == c) return c} else this.each (function () {X.set (this, a, b)})}, null, b, arguments.length> 1, null,! 0)}, removeData: function (a) {вернуть this.each (function () {X.remove (this, a)})}}), r.extend ({ очередь: функция (а,b, c) {var d; если (a) вернуть b = (b || "fx") + "очередь", d = W.get (a, b), c && (! d || Array.isArray (c ) d = W.access (а, б, r.makeArray (с)): d.push (с)), д || []}, Dequeue: функция (а, б) {Ь = Ь ||» fx "; var c = r.queue (a, b), d = c.length, e = c.shift (), f = r._queueHooks (a, b), g = function () {r.dequeue ( a, b)}; "inprogress" === e && (e = c.shift (), d -), e && ("fx" === b && c.unshift ("inprogress"), удалить f.stop, e .call (a, g, f)) ,! d && f && f.empty.fire ()}, _ queueHooks: function (a, b) {var c = b + "queueHooks"; вернуть W.get (a, c) || ​​W .access (a, c, {empty: r.Callbacks ("однажды память"). add (function () {W.remove (a, [b + "очередь", c])})})}}), r .fn.extend ({queue: function (a, b) {var c = 2; вернуть "строку"! = typeof a && (b = a, a = "fx", c -), arguments.length <c? r.queue (this [0], a): void 0 === b? this: this.each (function () {var c = r.queue (this, a, b); r._queueHooks (this, a), "fx" === a && "inprogress"! == c [0] && r.dequeue ( this, a)})}, dequeue: function (a) {вернуть this.each (function () {r.dequeue (this, a)})}, clearQueue: function (a) {вернуть this.queue (a | | "fx", [])}, обещание: function (a, b) {var c, d = 1, e = r.Deferred (), f = this, g = this.length, h = function () { --d || e.resolveWith (f, [f])}; "строка"! = typeof a && (b = a, a = void 0), a = a || "fx"; while (g--) c = W.get (f [g], a + "queueHooks"), c && c.empty && (d ++, c.empty.add (h)); вернуть h (), e.promise (b)}}); var aa = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [+ -]? \ d + |) /. source, ba = new RegExp ("^ (?: ([ + -]) = |) ( "+ аа +") ([AZ%] *) $», "я"), са = [ "Top", "вправо", "Снизу", "влево"], да = function (a, b) {return a = b || a, "none" === a.style.дисплей || "" === a.style.display && r.contains (a.ownerDocument, а) && "нет" === r.css (а, "дисплей")}, еа = функция (а, б, в , d) {var e, f, g = {}; для (f в b) g [f] = a.style [f], a.style [f] = b [f]; e = c.apply ( a, d || []); для (f в b) a.style [f] = g [f]; return e}; функция fa (a, b, c, d) {var e, f = 1, g = 20, h = d? function () {return d.cur ()}: function () {return r.css (a, b, "")}, i = h (), j = c && c [3] || (r.cssNumber [б] "?": "точек"), к = (r.cssNumber [б] || "! точек" == J && + я) && ba.exec (r.css (а, б )); if (k && k [3]! == j) {j = j || k [3], c = c || [], k = + i || 1; do f = f || ".5 ", k / = f, r.style (a, b, k + j); в то время как (f! == (f = h () / i) && 1! == f && - g)} вернуть c && (k = + к || + I || 0, е = с [1] к + (с [1] + 1) * с [2]: + с [2], д && (d.unit = J, d.start = k, d.end = e)), e} var ga = {}; функция ha (a) {var b, c = a.ownerDocument, d = a.nodeName, e = ga [d]; вернуть e? e :(Б = c.body.appendChild (c.createElement (д)), е = r.css (б, "дисплей"), b.parentNode.removeChild (б), "нет" === && е (е =» block "), ga [d] = e, e)} функция ia (a, b) {for (var c, d, e = [], f = 0, g = a.length; f <g; f ++) d = A [F], d.style && (с = d.style.display, б? ( "нет" === C && (е [е] = W.get (д, "дисплей") || нуль, е [F] || (d.style.display = "")), "" === d.style.display && да (г) && (е [е] = га (г))): "нет" == с && (е [е] = "нет", W.set (д, "дисплей", с))), ибо (F = 0; ф <г;! е ++), нуль = E [F] && (в [F ] .style.display = e [f]); return a} r.fn.extend ({show: function () {return ia (this,! 0)}, hide: function () {return ia (this)} , toggle: function (a) {return "boolean" == typeof a? a? this.show (): this.hide (): this.each (function () {da (this)? r (this) .show (): r (this) .hide ()})}}); var ja = / ^ (?:Флажок | радио) $ / я, ка = / <([AZ] [^ \ / \ 0> \ x20 \ т \ г \ п \ е] +) / я, л = / ^ $ | \ / (?: java | ecma) script / i, ma = {option: [1, "<select multip = 'multip'>", "</ select>"], thead: [1, "<table>", "</ table > "], колонка: [2," <таблица> <COLGROUP> " "</ COLGROUP> </ таблицы>"], тр: [2, "<таблица> <TBODY>"," </ TBODY> < / table> "], тд: [3," <таблица> <TBODY> <TR>», "</ TR> </ TBODY> </ table>"], _ по умолчанию: [0, "", ""] }; ma.optgroup = ma.option, ma.tbody = ma.tfoot = ma.colgroup = ma.caption = ma.thead, ma.th = ma.td; функция na (a, b) {var c; возврат c = "undefined"! = typeof a.getElementsByTagName? a.getElementsByTagName (b || "*"): "undefined"! = typeof a.querySelectorAll? a.querySelectorAll (b || "*"): [], void 0 === b || b && B (a, b)? r.merge ([a], c): c} функция oa (a, b) {для (var c = 0, d = a.length; c <d; c ++) W.set (a [c], "globalEval",! b || W.get (b [c], "globalEval"))} var pa = / <| & #? \ w +; /; функция qa (a, b, c, d, e) {for (var f, g, h, i, j, k, l = b.createDocumentFragment () , м = [], п ​​= 0, а = a.length; п <о, п ++), если (е = а [п], е || 0 === е) если ( "объект" === г. type (f)) r.merge (m, f.nodeType? [f]: f), иначе if (pa.test (f)) {g = g || l.appendChild (b.createElement ("div") ), ч = (ka.exec (е) || [ "", ""]) [1] .toLowerCase (), I = ма [ч] || ma._default, g.innerHTML = я [1] + r.htmlPrefilter (е) + г [2], к = I [0], в то время (к -) г = g.lastChild; r.merge (м, g.childNodes), г = l.firstChild, г. textContent = ""} else m.push (b.createTextNode (f)); l.textContent = "", n = 0; while (f = m [n ++]) if (d && r.inArray (f, d)> - 1) e && e.push (f), иначе if (j = r.содержит (f.ownerDocument, е), г = па (l.appendChild (е), "сценарий"), J && габаритная (г), в) {к = 0, тогда (F = G [K ++]) la.test ( f.type || "") && c.push (f)} return l}! function () {var a = d.createDocumentFragment (), b = a.appendChild (d.createElement ("div")), c = d.createElement ( "вход"); c.setAttribute ( "тип", "радио"), c.setAttribute ( "проверено", "проверено"), c.setAttribute ( "название", "т"), б. AppendChild (с), o.checkClone = b.cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, b.innerHTML = "<TextArea> х </ TextArea>", o.noCloneChecked = !! б. cloneNode (! 0) .lastChild.defaultValue} (); var ra = d.documentElement, sa = / ^ key /, ta = / ^ (?: мышь | указатель | contextmenu | перетаскивать | drop) | click /, ua = /^([^.]*)(?:\.(.+)|)/;function va () {return! 0} function wa () {return! 1} function xa () {try {return d.activeElement} catch (a) {}} функция ya (a, b, c, d, e, f) {var g, h; if ("object" == typeof b) {"string"! = typeof c && (d = d || c, c = void 0); для (h в b) ya (a, h, c, d, b [h], f); вернуть a} if (null == d && null == e? ( e = c, d = c = void 0): null == e && ("string" == typeof c? (e = d, d = void 0) :( e = d, d = c, c = void 0) ), e ===! 1) e = wa, иначе, если (! e) вернет a; вернет 1 === f && (g = e, e = function (a) {return r (). off (a), g.apply (это, аргументы)}, e.guid = g.guid || (g.guid = r.guid ++)), a.each (функция () {r.event.add (это, б, д, d, c)})} r.event = {global: {}, add: function (a, b, c, d, e) {var f, g, h, i, j, k, l, m, n , о, р, д = W.get (а), если (Q) {c.handler && (F = C, C = f.handler, е = f.selector), е && r.find.matchesSelector (ра, е) , c.guid || (c.guid = r.guid ++), (I = q.events) || (I = q.events = {}), (г = q.handle) || (г = д. handle = function (b) {return "undefined"! = typeof r && r.event.triggered! == b.type? r.event.dispatch.apply (a, arguments): void 0}), b = (b || ""). match (L) || [""], j = b.length; while (j -) h = ua.exec (б [J]) || [], п ​​= р = ч [1], о = (ч [2] || ""). сплит ( ""). рода (), п && ( L = r.event.special [N] || {}, п = (е l.delegateType: l.bindType) || N, L = r.event.special [п] || {}, к = г .extend ({тип: п, OrigType: р, данные: д, обработчик: C GUID: c.guid, селектор: е, needsContext: е && r.expr.match.needsContext.test (е), пространство имен: o.join ( "")}, е), (т = [п]) || (т = [п] = [], m.delegateCount = 0, l.setup && l.setup.call (а, г, о , г)! ==! 1 || a.addEventListener && a.addEventListener (п, г)), l.add && (l.add.call (а, к), k.handler.guid || (k.handler.guid = c.guid)), е m.splice (m.delegateCount ++ 0, к): m.push (к), r.event.global [п] = 0)}}, удалить: функция (а, b, c, d, e) {var f, g, h, i, j, k, l, m, n, o, p, q = W.hasData (a) && W.get (a); if (q && (I = q.events)) {Ь = (Ь || "") .Match (Л) || [ ""], J = b.length; при этом (J -), если (ч = ua.exec (б [J]) || [], п ​​= р = ч [1 ], O = (ч [2] || ""). сплит ( ""). рода (), п) {л = r.event.special [п] || {}, п = (д? л .delegateType: l.bindType) || n, m = i [n] || [], h = h [2] && new RegExp ("(^ | \\.)" + o.join ("\\. ( ?..: * \\ |) ") +" (\\ | $) "), г = е = m.length, тогда (ф -) к = т [ф] ,! е && р == к.! .origType || с && c.guid! == k.guid || ч &&! h.test (k.namespace) || d && d! == k.selector && ( "**"! == d ||! k.selector) || (m.splice (е, 1), k.selector && m.delegateCount -, l.remove && l.remove.call (а, к));! г && && m.length (l.teardown && l.teardown.call (а, o, q.handle)! ==! 1 || r.removeEvent (a, n, q.handle), удалить i [n])} еще для (n in i) r.event.remove (a, n + b [j], c, d,! 0); r.isEmptyObject (i) && W.remove (a, «обрабатывать события»)}}, рассылка: function (a) {var b = r.event.fix (a), c, d, e, f, g, h, i = новый массив (arguments.length), j = (W.get (this, "events") || {}) [b. тип] || [], K = r.event.special [b.type] || {}, ибо (я [0] = Ь, с = 1; с <arguments.length; C ++) я [с] = аргументы [с], если (!!! b.delegateTarget = это, k.preDispatch || k.preDispatch.call (это, б) == 1) {ч = r.event.handlers.call (это, Ь, к), с = 0, тогда как ((е = ч [C ++]) && b.isPropagationStopped ()) {b.currentTarget = f.elem, д = 0;! в то время как ((г = f.handlers [d ++]) &&! b.isImmediatePropagationStopped ()) b.rnamespace &&! b.rnamespace.test (g.namespace) || (b.handleObj = г, b.data = g.data, е = ((r.event.special [г .origType] || {}). handle || g.handler) .apply (f.elem, i), void 0! == e && (b.result = e) ===! 1 && (b.preventDefault () , b.stopPropagation ()))} return k.postDispatch && k.postDispatch.call (this, b), b.result}}, обработчики: function (a, b) {var c, d, e, f, g, h = [], I = b.delegateCount, J = a.target; если (я && J.! NODETYPE && ( "нажмите" === a.type && a.button> = 1)) для (, J == это;! J = j.parentNode || это), если (1 === j.nodeType && ( "щелчок" ! == a.type || j.disabled == 0)) {для (е = [], г = {}, с = 0;! с <я; C ++) d = B [C], е = d.selector + "", void 0 === g [e] && (g [e] = d.needsContext? r (e, this) .index (j)> - 1: r.find (e, this, null , [j]). length), g [e] && f.push (d); f.length && h.push ({elem: j, обработчики: f})} return j = this, i <b.length && h.push ( {элем: J, обработчики: b.slice (я)}), ч}, addProp: функция (а, б) {Object.defineProperty (r.Event.prototype, а, {перечислимы: 0, конфигурируемый: 0 , get: r.isFunction (b)? function () {if (this.originalEvent) return b (this.originalEvent)}: function () {if (this.originalEvent) вернуть this.originalEvent [a]}, установить: функция (б) {Object.defineProperty (это, а, {перечислимы: 0, конфигурируемый: 0, записываемый: 0, значение: Ь})}})}, исправление:function (a) {вернуть a [r.expando]? a: new r.Event (a)}, специальное: {load: {noBubble:! 0}, focus: {trigger: function () {if (this! = = xa () && this.focus) вернуть this.focus () ,! 1}, DelegateType: "focusin"}, blur: {trigger: function () {if (this === xa () && this.blur) вернуть this .blur () ,! 1}, DelegateType: "focusout"}, нажмите: {trigger: function () {if ("checkbox" === this.type && this.click && B (this, "input")) вернуть this.click () ,! 1}, _ по умолчанию: function (a) {return B (a.target, "a")}}, перед загрузкой: {postDispatch: function (a) {void 0! == a.result && a.originalEvent && (a .originalEvent.returnValue = a.result)}}}}, r.removeEvent = функция (а, б, в) {a.removeEventListener && a.removeEventListener (б, в)}, r.Event = функция (а, б) { вернуть этот экземпляр r.Event? (a && a.type? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue ===! 1? va: wa, this.target = a.target && 3 === a.target.nodeType? a.target.parentNode: .цель, this.currentTarget = a.currentTarget, this.relatedTarget = a.relatedTarget): this.type = а, б && r.extend (это, б), this.timeStamp = а && a.timeStamp || r.now (), void (this [r.expando] =! 0)): новый r.Event (a, b)}, r.Event.prototype = {constructor: r.Event, isDefaultPrevented: wa, isPropagationStopped: wa, isImmediatePropagationStopped: wa, isSimulated:! 1, protectDefault: function () {var a = this.originalEvent; this.isDefaultPrevented = va, a &&! this.isSimulated && a.preventDefault ()}, stopPropagation: function () {var a = this.originalEvent; this. isPropagationStopped = va, a &&! this.isSimulated && a.stopPropagation ()}, stopImmediatePropagation: function () {var a = this.originalEvent; this.! IsImmediatePropagationStopped = ва, A && && this.isSimulated a.stopImmediatePropagation (), this.stopPropagation ()}}, r.each ({клавишу Alt: 0, пузыри: 0, отменяемый: 0, changedTouches: 0, ctrlKey :! 0, деталь: 0, EventPhase: 0, metaKey: 0, pageX: 0, Пейджи: 0, shiftKey: 0, вид: 0, "символ": 0, charCode: 0, ключ : 0, KEYCODE: 0, кнопка: 0, кнопки: 0, clientX: 0, clientY: 0, OffsetX: 0, OffsetY: 0, pointerId: 0, pointerType: 0, ScreenX :! 0, screenY:! 0, targetTouches:! 0, toElement:! 0, касания:! 0, который: function (a) {var b = a.button; вернуть null == a.which && sa.test (a. type)? null! = a.charCode? a.charCode: a.keyCode:! a.which && void 0! == b && ta.test (a.type)? 1 & b? 1: 2 & b? 3: 4 & b? 2: 0: a .which}}, r.event.addProp), r.each ({MouseEnter: "Mouseover", MouseLeave: "MouseOut", pointerenter: "pointerover", pointerleave: "pointerout"},function (a, b) {r.event.special [a] = {DelegateType: b, bindType: b, handle: function (a) {var c, d = this, e = a.relatedTarget, f = a.handleObj ; вернуть e && (e === d || r.contains (d, e)) || (a.type = f.origType, c = f.handler.apply (this, arguments), a.type = b) , c}}}), r.fn.extend ({on: function (a, b, c, d) {вернуть ya (this, a, b, c, d)}, one: function (a, b, c, d) {вернуть ya (this, a, b, c, d, 1)}, off: function (a, b, c) {var d, e; if (a && a.preventDefault && a.handleObj) вернуть d = a .handleObj, г (a.delegateTarget) .off (d.namespace d.origType + d.namespace? " ": d.origType, d.selector, d.handler), это, если (" объект" == TypeOf a) {for (e in a) this.off (e, b, a [e]); вернуть this} return b! ==! 1 && "function"! = typeof b || (c = b, b = void 0), c ===! 1 && (c = wa), this.each (function () {r.event.remove (this, a, c, b)})}}); var za = / <(? ! область | ш | цв | встраивать | час | IMG | вход | ссылка | мета | пары) (([AZ] [^ \ / \ 0>\ X20 \ т \ г \ п \ е] *) [^>] *) \ /> / ги, Аа = / <сценарий | <стиль | <ссылка / я, Ba = / проверено \ s * (?: [ ^ =] | = \ с * .Checked) / я, Са = / ^ справедливо \ / (*) /, Da = / ^ \ с * <(:..!? \ [CDATA \ [| -) | (?: \] \] | -)> \ s * $ / g; функция Ea (a, b) {return B (a, "таблица") && B (11! == b.nodeType? b: b. firstChild, "tr")? r ("> tbody", a) [0] || a: a} функция Fa (a) {return a.type = (null! == a.getAttribute ("type")) + "/" + a.type, a} функция Ga (a) {var b = Ca.exec (a.type); return b? a.type = b [1]: a.removeAttribute ("type"), a} функция Ha (a, b) {var c, d, e, f, g, h, i, j; if (1 === b.nodeType) {if (W.hasData (a) && (f =) W.access (a), g = W.set (b, f), j = f.events)) {удалить g.handle, g.events = {}; для (e в j) для (c = 0, д = у [е] .length; с <д; C ++) r.event.add (б, д, J [е] [с])} X.hasData (а) && (ч = X.access (а) , i = r.extend ({}, h), X.set (b, i))}} функция Ia (a, b) {var c = b.nodeName.toLowerCase (); «вход»=== c && ja.test (a.type)? b.checked = a.checked: "input"! == c && "textarea"! == c || (b.defaultValue = a.defaultValue)} функция Ja (a , b, c, d) {b = g.apply ([], b); var e, f, h, i, j, k, l = 0, m = длина a, n = m-1, q = b [0], s = r.isFunction (q); if (s || m> 1 && "string" == typeof q &&! o.checkClone && Ba.test (q)) return a.each (function (e) { var f = a.eq (e); s && (b [0] = q.call (this, e, f.html ())), Ja (f, b, c, d)}); if (m && ( е = QA (Ь, а [0] .ownerDocument,! 1, а, г), е = e.firstChild, 1 === e.childNodes.length && (е = е), е || г)) {для (ч = r.map (па (е, "сценарий"), Fa), I = h.length, л <т; л ++)! = е, л == п && (J = r.clone (J ,! ! 0, 0), я && r.merge (ч, на (J, "сценарий"))), c.call (а [л], J, L), если (я) для (к = ч [h.length -1] .ownerDocument, r.map (ч, Ga), л = 0; л <я;! л ++), J = ч [л], la.test (j.type || "") && W.access ( J, "globalEval") && r.contains (k, j) && (j.src? r._evalUrl && r._evalUrl (j.src): p (j.textContent.replace (Da, ""), k))} вернуть функцию} Ka (a , b, c) {для (var d, e = b? r.filter (b, a): a, f = 0; null! = (d = e [f]); f ++) c || 1! = = d.nodeType || r.cleanData (па (г)), d.parentNode && (с && r.contains (d.ownerDocument, д) && габаритная (па (д, "сценарий")), d.parentNode.removeChild (д) ); return a} r.extend ({htmlPrefilter: function (a) {return a.replace (za, "<$ 1> </ $ 2>")}, clone: ​​function (a, b, c) {var d, (! 0) д, е, ж, з = a.cloneNode, I = r.contains (a.ownerDocument, а);!!! если ((o.noCloneChecked || 1 == a.nodeType && 11 == а. NODETYPE || r.isXMLDoc (а))) для (г = па (з), F = па (а), д = 0, е = f.length; д <е, г ++), Ia, (F [d], г [г]), если (б) если (с) для (F = F || на (а), г = г || на (з), д = 0, е = f.length; д <е; d ++) Ha (f [d], g [d]); иначе Ha (a, h); вернуть g = na (h, "script"), длина g> 0 && oa (g,! i &&na (a, "script")), h}, cleanData: function (a) {for (var b, c, d, e = r.event.special, f = 0; пустота 0! == (c = a [f]); f ++) if (U (c)) {if (b = c [W.expando]) {if (b.events) для (d в b.events) e [d]? r.event. удалить (c, d): r.removeEvent (c, d, b.handle); c [W.expando] = void 0} c [X.expando] && (c [X.expando] = void 0)}} }), r.fn.extend ({detach: function (a) {return Ka (this, a,! 0)}, remove: function (a) {return Ka (this, a)}, text: function (a ) {return T (this, function (a) {return void 0 === a? r.text (this): this.empty (). each (function () {1! == this.nodeType && 11! == this .nodeType && 9! == this.nodeType || (this.textContent = a)})}, null, a, arguments.length)}, append: function () {вернуть Ja (this, аргументы, функцию (a) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var b = Ea (this, a); b.appendChild (a)}})}, prepend : function () {вернуть Ja (this, аргументы, function (a) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var b = Ea (this, a); b.insertBefore (a, b.firstChild)}})}, before: function () {вернуть Ja (this, аргументы, function (a) {this.parentNode && this.parentNode.insertBefore (a, this)})}, after: function () {return Ja (this, аргументы, function (a) {this.parentNode && this.parentNode.insertBefore (a, this .nextSibling)})}, empty: function () {for (var a, b = 0; null! = (a = this [b]); b ++) 1 === a.nodeType && (r.cleanData (na ( a,! 1)), a.textContent = ""); вернуть это}, clone: ​​function (a, b) {вернуть a = null! = a && a, b = null == b? a: b, this.map (function () {return r.clone (this, a, b)})}, html: function (a) {return T (this, function (a) {var b = this [0] || {}, c = 0, d = this.length; if (void 0 === a && 1 === b.nodeType) возвращает b.innerHTML; if ("string" == typeof a &&! Aa.test (a) &&! Ma [( ka.exec (а) || [ "", ""]) [1] .toLowerCase ()]) {а = г.htmlPrefilter (а); попытка {для (; с <д; C ++) б = это [с] || {}, 1 === b.nodeType && (r.cleanData (па (б, 1)), б!. innerHTML = a); b = 0} catch (e) {}} b && this.empty (). append (a)}, null, a, arguments.length)}, replaceWith: function () {var a = []; вернуть Ja (this, arguments, function (b) {var c = this.parentNode; r.inArray (this, a) <0 && (r.cleanData (na (this)), c && c.replaceChild (b, this))} , а)}}), r.each ({appendTo: "Append", prependTo: "перед именем", InsertBefore: "до", InsertAfter: "после", replaceAll: "ReplaceWith"}, функции (а, б) { r.fn [a] = function (a) {for (var c, d = [], e = r (a), f = e.length-1, g = 0; g <= f; g ++) c = g === f? this: this.clone (! 0), r (e [g]) [b] (c), h.apply (d, c.get ()); вернуть this.pushStack (d) }}); var La = / ^ margin /, Ma = new RegExp ("^ (" + aa + ") (?! px) [az%] + $", "i"), Na = function (b) { var c = b.ownerDocument.defaultView;return c && c.opener || (c = a), c.getComputedStyle (b)} ;! function () {function b () {if (i) {i.style.cssText = "box-sizing: border-box; положение: относительное; отображение: блок; поле: авто; граница: 1 пиксель; отступ: 1 пиксель; верх: 1%; ширина: 50% ", i.innerHTML =" ", ra.appendChild (h); var b = a. getComputedStyle (я);! с = "1%" == b.top, г = "2рх" === b.marginLeft, е = "4px" === b.width, i.style.marginRight = "50 % ", f =" 4px "=== b.marginRight, ra.removeChild (h), i = null}} var c, e, f, g, h = d.createElement (" div "), i = d .createElement ( "ДИВ"!); i.style && (i.style.backgroundClip = "Content-бокс", i.cloneNode (0) .style.backgroundClip = "", o.clearCloneStyle = "содержание ящика" == = i.style.backgroundClip, h.style.cssText = "граница: 0; ширина: 8px; высота: 0; сверху: 0; слева: -9999px; отступы: 0; Верхнее поле: 1px; положение: абсолютный", часappendChild (i), r.extend (o, {pixelPosition: function () {return b (), c}, boxSizingReliable: function () {return b (), e}, pixelMarginRight: function () {return b () , f}, reliableMarginLeft: function () {return b (), g}}))} (); функция Oa (a, b, c) {var d, e, f, g, h = a.style; return C = C || Na (а), с && (г = c.getPropertyValue (б) || с [Ь] ""! == г || r.contains (a.ownerDocument, а) || (г = r.style (а, б)) ,! o.pixelMarginRight () && Ma.test (г) && La.test (б) && (д = h.width, е = h.minWidth, е = h.maxWidth, ч. minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), пустота 0! == g? g + "": g } функция Pa (a, b) {return {get: function () {return a ()? void удалить this.get: (this.get = b) .apply (this, arguments)}}} var Qa = / ^ (нет | таблица (- с [еа]) +?!.) / Ра = / ^ - /, Sa = {позиция: "абсолютный", видимость: "скрытый", дисплей: "блок"}, Та = {letterSpacing: "0",fontWeight: "400"}, Ua = ["Webkit", "Moz", "ms"], Va = d.createElement ("div"). style; функция Wa (a) {if (a в Va) возвращает a ; var b = a [0] .toUpperCase () + a.slice (1), c = Ua.length; тогда как (c -), если (a = Ua [c] + b, a в Va) возвращает a} функция Xa (a) {var b = r.cssProps [a]; return b || (b = r.cssProps [a] = Wa (a) || a), b} функция Ya (a, b, c) {var d = ba.exec (b); вернуть d? Math.max (0, d [2] - (c || 0)) + (d [3] || "px"): b} функция Za ( a, b, c, d, e) {var f, g = 0; для (f = c === (d? "border": "content")? 4: "width" === b? 1: 0, х <4;? F + = 2) "запас" === C && (д + = r.css (а, с + ч [е] ,! 0, е)), д ( "содержание" === C && (g- = r.css (а, "набивка" + ч [е] ,! 0, е)), "запас"! == с && (g- = r.css (а, "граница" + ч [е ] + "Ширина",! 0, е))) :( G + = r.css (а, "обивка" + Ca [е] ,! 0, е), "заполнение"! == C && (д + = г.css (a, "border" + ca [f] + "Width",! 0, e))); return g} функция $ a (a, b, c) {var d, e = Na (a), f = Oa (a, b, e), g = "border-box" === r.css (a, "boxSizing",! 1, e); вернуть Ma.test (f)? F: (d = g && (o.boxSizingReliable () || е === a.style [б]), "авто" === е && (е = а [ "смещение" + Ь [0] .toUpperCase () + b.slice (1 )]), е = parseFloat (е) || 0, е + Za (а, б, в || (г "граница": "содержание"), д, е) + "ПВ")} r.extend ({cssHooks: {opacity: {get: function (a, b) {if (b) {var c = Oa (a, "opacity"); return "" === c? "1": c}}} }, cssNumber: {animationIterationCount: 0, ColumnCount: 0, fillOpacity: 0, flexGrow: 0, flexShrink: 0, FontWeight: 0, LineHeight: 0, непрозрачность: 0, заказ: 0, сироты: 0, вдовы: 0, ZIndex: 0, масштаб: 0}, cssProps: { "поплавок": "cssFloat"}, стиль: функция (а, б, в, г) {если (а && 3! == a.nodeType && 8! == а.nodeType && a.style) {var e, f, g, h = r.camelCase (b), i = Ra.test (b), j = a.style; вернуть i || (b = Xa (h)), g = r.cssHooks [b] || r.cssHooks [h], void 0 === c? g && "get" в g && void 0! == (e = g.get (a,! 1, d))? e : j [b] :( f = typeof c, "string" === f && (e = ba.exec (c)) && e [1] && (c = fa (a, b, e), f = "число" "!), нуль = с && с === с && (" число "=== е && (с + = е && е [3] || (r.cssNumber [ч]?" ":" ПВ ")), o.clearCloneStyle || ""! == c || 0! == b.indexOf ("фон") || (j [b] = "наследовать"), g && "set" в g && void 0 === (c = g.set ( a, c, d)) || (i? j.setProperty (b, c): j [b] = c)), void 0)}}, css: function (a, b, c, d) {var e, f, g, h = r.camelCase (b), i = Ra.test (b); return i || (b = Xa (h)), g = r.cssHooks [b] || r.cssHooks [h], g && "get" в g && (e = g.get (a,! 0, c)), void 0 === e && (e = Oa (a, b, d)), "нормальный" === e && b в Ta && (e = Ta [b]), "" === c || c? (f = parseFloat (e), ! с === 0 || isFinite (е) е || 0: е): е}}), r.each ([ "высота", "ширина"], функция (а, б) {r.cssHooks [Ь] = {получаем:!. функция (а, в, г) {если (с) возвращение Qa.test (r.css (а, "дисплей")) || a.getClientRects () длина && a.getBoundingClientRect () .width? $ a (a, b, d): ea (a, Sa, function () {return $ a (a, b, d)})}, set: function (a, c, d) {var e , f = d && Na (a), g = d && Za (a, b, d, "border-box" === r.css (a, "boxSizing",! 1, f), f); вернуть g && (e = ba.exec (с)) && "ПВ"! == (е [3] || "ПВ") && (a.style [Ь] = с, с = r.css (а, б)), Я. ( а, в, г)}}}), r.cssHooks.marginLeft = Па (o.reliableMarginLeft, функция (а, б) {если (б) возврата (parseFloat (Оа (а, "MarginLeft")) || а .getBoundingClientRect (). left-ea (a, {marginLeft: 0}, function () {return a.getBoundingClientRect ()} слева)) + "ПВ"}), r.each ({поле: "", обивка: "", граница: "Ширина"}, функция (а, б) {r.cssHooks [а + b] = {раскрыть: функция (с) {для (var d = 0, e = {}, f = "строка" == typeof c? c.split (""): [c]; d <4; d ++ ) e [a + ca [d] + b] = f [d] || f [d-2] || f [0]; return e}}, La.test (a) || (r.cssHooks [ a + b] .set = Ya)}), r.fn.extend ({css: function (a, b) {return T (this, function (a, b, c) {var d, e, f = { }, г = 0; если (Array.isArray (б)) {для (d = Na (а), е = b.length; г <е; г ++) П [Ь [г]] = r.css (а , b [g] ,! 1, d); return f} return void 0! == c? r.style (a, b, c): r.css (a, b)}, a, b, аргументы. length> 1)}}), r.fn.delay = function (b, c) {return b = r.fx? r.fx.speeds [b] || b: b, c = c || "fx" , this.queue (c, function (c, d) {var e = a.setTimeout (c, b); d.stop = function () {a.clearTimeout (e)}})}, function () {var а = d.createElement ( "вход"), б = d.createElement ( "выбрать"), с = Ь.AppendChild (d.createElement ( "вариант")); "! == a.value, o.optSelected = c.selected, а = d.createElement (" a.type = "флажок", o.checkOn = "вход" ), a.value = "t", a.type = "radio", o.radioValue = "t" === a.value} (); var _a, ab = r.expr.attrHandle; r.fn. extend ({attr: function (a, b) {return T (this, r.attr, a, b, arguments.length> 1)}, removeAttr: function (a) {вернуть this.each (function () {r .removeAttr (this, a)})}}), r.extend ({attr: function (a, b, c) {var d, e, f = a.nodeType; if (3! == f && 8! == f && 2! == f) вернуть "undefined" == typeof a.getAttribute? r.prop (a, b, c) :( 1 === f && r.isXMLDoc (a) || (e = r.attrHooks [b. toLowerCase ()] || (r.expr.match.bool.test (b)? _ a: void 0)), void 0! == c? null === c? void r.removeAttr (a, b): e && "set" в e && void 0! == (d = e.set (a, c, b))? d: (a.setAttribute (b, c + ""), c): e && "get" в e && null! == (d = e.get (a, b))? d: (d = r.find.attr (a, b), null == d? void 0: d))} , attrHooks: {type: {set: function (a, b) {if (! o.radioValue && "radio" === b && B (a, "input")) {var c = a.value; вернуть a.setAttribute ( "type", b), c && (a.value = c), b}}}}, removeAttr: function (a, b) {var c, d = 0, e = b && b.match (L); if (e && 1 === a.nodeType) while (c = e [d ++]) a.removeAttribute (c)}}), _ a = {set: function (a, b, c) {return b ===! 1? r. removeAttr (а, с): a.setAttribute (с, с), с}}, r.each (r.expr.match.bool.source.match (/ \ W + / г), функция (а, б) { var c = ab [b] || r.find.attr; ab [b] = function (a, b, d) {var e, f, g = b.toLowerCase (); вернуть d || (f = ab [g], ab [g] = e, e = null! = c (a, b, d)? g: null, ab [g] = f), e}}); var bb = / ^ (?: input | select | textarea | button) $ / i, cb = / ^ (?: a | area) $ / i; r.fn.extend ({prop: function (a, b) {return T (this, r. проп, а, б, arguments.length> 1)}, removeProp:function (a) {вернуть this.each (function () {удалить this [r.propFix [a] || a]})}}), r.extend ({prop: function (a, b, c) {var d, e, f = a.nodeType; if (3! == f && 8! == f && 2! == f) вернуть 1 === f && r.isXMLDoc (a) || (b = r.propFix [b] || b, e = r.propHooks [b]), void 0! == c? e && "set" в e && void 0! == (d = e.set (a, c, b))? d: a [b] = c: e && "get" в e && null! == (d = e.get (a, b))? d: a [b]}, propHooks: {tabIndex: {get: function (a) {var b = r .find.attr (a, "tabindex"); return b? parseInt (b, 10): bb.test (a.nodeName) || cb.test (a.nodeName) && a.href? 0: -1}} }, propFix: {"for": "htmlFor", "class": "className"}}), o.optSelected || (r.propHooks.selected = {get: function (a) {var b = a.parentNode ; вернуть b && b.parentNode && b.parentNode.selectedIndex, null}, установить: function (a) {var b = a.parentNode; b && (b.selectedIndex,b.parentNode && b.parentNode.selectedIndex)}}), r.each ([ "TabIndex", "доступен только для чтения", "MaxLength", "CELLSPACING", "CELLPADDING", "RowSpan", "COLSPAN", "useMap",» frameBorder "," contentEditable "], function () {r.propFix [this.toLowerCase ()] = this}); функция db (a) {var b = a.match (L) || []; вернуть b. функция join ("")} eb (a) {return a.getAttribute && a.getAttribute ("class") || ""} r.fn.extend ({addClass: function (a) {var b, c, d, e , f, g, h, i = 0; если (r.isFunction (a)) возвращает this.each (function (b) {r (this) .addClass (a.call (this, b, eb (this)) )}); if ("string" == typeof a && a) {b = a.match (L) || []; while (c = this [i ++]) if (e = eb (c), d = 1 = == c.nodeType && "" + db (e) + "") {g = 0; while (f = b [g ++]) d.indexOf ("" + f + "") <0 && (d + = f + ""); h = db (d), e! == h && c.setAttribute ("class", h)}} вернуть это}, removeClass: function (a) {var b, c, d, e, f, g, h, i = 0; если (r.isFunction (a)) возвращает this.each (function (b) {r (this) .removeClass (a.call (this, b, eb (this) ))}); if (! arguments.length) возвращает this.attr ("class", ""); if ("string" == typeof a && a) {b = a.match (L) || []; while (c = this [i ++]) if (e = eb (c), d = 1 === c.nodeType && "" + db (e) + "") {g = 0; while (f = b [g ++] ) while (d.indexOf ("" + f + "")> - 1) d = d.replace ("" + f + "", ""); h = db (d), e! == h && c.setAttribute ( "class", h)}} вернуть это}, toggleClass: function (a, b) {var c = typeof a; вернуть "boolean" == typeof b && "string" === c? b? this.addClass (a ): this.removeClass (а): r.isFunction (а) this.each (функция (с) {г (это).toggleClass (a.call (this, c, eb (this), b), b)}): this.each (function () {var b, d, e, f; if ("string" === c) {d = 0, е = г (это), е = a.match (L) || []; в то время как (Ь = F [d ++]) e.hasClass (б) e.removeClass (б): е. addClass (b)} else void 0! == a && "boolean"! == c || (b = eb (this), b && W.set (this, "__ className __", b), this.setAttribute && this.setAttribute ("class ", b || a ===! 1?" ": W.get (this," __ className __ ") ||" "))})}, hasClass: function (a) {var b, c, d = 0 ; b = "" + a + ""; while (c = this [d ++]) if (1 === c.nodeType && ("" + + db (eb (c)) + "") .indexOf (b)> - 1) return! 0; return! 1}}); var fb = / \ r / g; r.fn.extend ({val: function (a) {var b, c, d, e = this [0]; {if (arguments.length) возвращает d = r.isFunction (a), this.each (function (c) {var e; 1 === this.nodeType && (e = d? a.call (this, c, r) (это) .val ()): а, нуль == е е = "":"число" == typeof e? e + = "": Array.isArray (e) && (e = r.map (e, function (a) {return null == a? "": a + ""})), b = r.valHooks [this.type] || r.valHooks [this.nodeName.toLowerCase ()], b && "set" в b && void 0! == b.set (this, e, "value") || ( this.value = e))}); если (e) вернуть b = r.valHooks [e.type] || r.valHooks [e.nodeName.toLowerCase ()], b && "get" в b && void 0! == (c = b.get (e, "value"))? c: (c = e.value, "string" == typeof c? c.replace (fb, ""): null == c? "": c)}}}), r.extend ({valHooks: {option: {get: function (a) {var b = r.find.attr (a, "value"); вернуть null! = b? b: db (r.text (a))}}, выберите: {get: function (a) {var b, c, d, e = a.options, f = a.selectedIndex, g = "select-one" === ? a.type, ч = г нуль: [], г = г е + 1: e.length; для (d = F <0 я: г е:? 0; д <я; d ++), если (с = е [г], (с.выбран || д === е) &&! c.disabled && (! c.parentNode.disabled || B! (c.parentNode, "OPTGROUP"))) {если (б = г (с) .val (), g) return b; h.push (b)} return h}, set: function (a, b) {var c, d, e = a.options, f = r.makeArray (b), g = e.length ; while (g -) d = e [g], (d.selected = r.inArray (r.valHooks.option.get (d), f)> - 1) && (c =! 0); вернуть c || (a.selectedIndex = -1), е}}}}), r.each ([ "радио", "флажок"], функция () {r.valHooks [это] = {множество: функция (а, b) {if (Array.isArray (b)) возвращает a.checked = r.inArray (r (a) .val (), b)> - 1}}, o.checkOn || (r.valHooks [this] .get = function (a) {return null === a.getAttribute ("value")? "on": a.value})}); var gb = / ^ (?: focusinfocus | focusoutblur) $ /; r .extend (r.event, {trigger: function (b, c, e, f) {var g, h, i, j, k, m, n, o = [e || d], p = l.call (б, "тип") b.type: б, д = l.call (Ь, "пространство имен") b.namespace.split ( ""):? [];если (Н = I = е = е || D, 3! == e.nodeType && 8! == e.nodeType &&! gb.test (р + r.event.triggered) && (p.indexOf ( "")> -1 && (д = p.split (), р = q.shift (), q.sort () " "), к = p.indexOf (": ") <0 &&" на" + р, B = B [r.expando]? b: новый r.Event (p, "объект" == typeof b && b), b.isTrigger = f? 2: 3, b.namespace = q.join ("."), b.rnamespace = b.namespace? new RegExp ("(^ | \\.)" + q.join ("\\. (?:. * \\. |)") + "(\\. | $)"): null, b.result = void 0, b.target || (b.target = e), c = null == c? [b]: r.makeArray (c, [b]), n = r.event. специальные [р] || {}, е ||! n.trigger || n.trigger.apply (е, с)! ==! 1)) {если (! е &&! n.noBubble &&! r.isWindow (е )) {для (J = n.delegateType || р, gb.test (J + р) || (Н = h.parentNode); ч, H = h.parentNode) o.push (ч), I = час ; я === (e.ownerDocument || д) && o.push (i.defaultView || i.parentWindow || а)} г = 0;в то время как ((Н = О [г ++]) && b.isPropagationStopped (!)) b.type = г> 1 J: n.bindType || р, т = (W.get (ч, "события") || {}) [b.type] && W.get (ч, "ручка"), м && m.apply (Н, с), т = к && ч [к], м && && m.apply U (ч) && (b.result = m.apply (h, c), b.result ===! 1 && b.preventDefault ()); вернуть b.type = p, f || b.isDefaultPrevented () || n._default && n._default.apply (o.pop () , с)! ==! 1 ||! V (е) || к && r.isFunction (е [р]) &&! r.isWindow (е) && (я = E [K], я && (е [к] = null), r.event.triggered = p, e [p] (), r.event.triggered = void 0, i && (e [k] = i)), b.result}}, имитировать: функцию (a, b, c) {var d = r.extend (new r.Event, c, {type: a, isSimulated:! 0}); r.event.trigger (d, null, b)}}), r.fn .extend ({trigger: function (a, b) {вернуть this.each (function () {r.event.trigger (a, b, this)})}, triggerHandler: function (a, b) {var c = this [0]; if (c) возвращает r.event.trigger (a, b, c,! 0)}}), r.each ("размытие фокуса, фокусировка в фокусе, изменение размера, прокрутка, щелчок dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave изменить выбор выбрать отправить нажатие клавиши keypress keyup contextmenu" .split (""), function (a, b) {r.fn [b] = function (a, c) {вернуть arguments.length> 0? this.on (b, null, a, c): this.trigger (b)}}) , r.fn.extend ({hover: function (a, b) {return this.mouseenter (a) .mouseleave (b || a)}}), o.focusin = "onfocusin" в a, o.focusin | | r.each ({focus: "focusin", blur: "focusout"}, function (a, b) {var c = function (a) {r.event.simulate (b, a.target, r.event. fix (a))}; r.event.special [b] = {setup: function () {var d = this.ownerDocument || this, e = W.access (d, b); e || d.addEventListener (a, c,! 0), W.access (d, b, (e || 0) +1)}, разрыв: function () {var d = this.ownerDocument || this, e = W.access ( д, б) -1;? е W.access (д, б, д) :( d.removeEventListener (a, c,! 0), W.remove (d, b))}}}); var hb = / \ [\] $ /, ib = / \ r? \ n / g, jb = / ^ (?: отправить | кнопка | изображение | сбросить | файл) $ / i, kb = / ^ (?: input | select | textarea | keygen) / i; функция lb (a, b, c, d) {var e; если (Array.isArray (б)) r.each (б, функция (Ь, е) {с || hb.test (а) д (а, е): фунт (а + "[" + ( "объект" == typeof e && null! = e? b: "") + "]", e, c, d);
}); иначе if (c || "object"! == r.type (b)) d (a, b), иначе для (e in b) lb (a + "[" + e + "]", b [ e], c, d)} r.param = function (a, b) {var c, d = [], e = function (a, b) {var c = r.isFunction (b)? b (): б, г [D.Length] = encodeURIComponent (а) + "=" + encodeURIComponent (нуль == С "": C?)}, если (Array.isArray (а) || a.jquery && r.isPlainObject (! a)) r.each (a, function () {e (this.name, this.value)}); еще для (c в a) lb (c, a [c], b, e); вернуть d. join ("&")}, r.fn.extend ({serialize: function () {return r.param (this.serializeArray ())}, serializeArray: function () {return this.map (function () {var a = r.prop (this, "elements"); вернуть a? r.makeArray (a): this}). filter (function () {var a = this.type; вернуть this.name &&! r (this). есть! ( ": отключено") && kb.test (this.nodeName) && jb.test (а) && (this.checked || ja.test (а)!)}) карта (функция (а,.b) {var c = r (this) .val (); return null == c? null: Array.isArray (c)? r.map (c, function (a) {return {name: b.name, value : a.replace (там же, "\ г \ п")}}): {имя: b.name, значение:. c.replace (там же, "\ г \ п")}}) получаем ()}}) , r.fn.extend ({wrapAll: function (a) {var b; вернуть this [0] && (r.isFunction (a) && (a = a.call (this [0])), b = r ( a, this [0] .ownerDocument) .eq (0) .clone (! 0), this [0] .parentNode && b.insertBefore (this [0]), b.map (function () {var a = this; в то время как (a.firstElementChild) a = a.firstElementChild; вернуть a}). append (this)), this}, wrapInner: function (a) {return r.isthis [0] .ownerDocument) .eq (0) .clone (! 0), this [0] .parentNode && b.insertBefore (this [0]), b.map (function () {var a = this; while (a .firstElementChild) a = a.firstElementChild; вернуть a}). append (this)), this}, wrapInner: function (a) {return r.isthis [0] .ownerDocument) .eq (0) .clone (! 0), this [0] .parentNode && b.insertBefore (this [0]), b.map (function () {var a = this; while (a .firstElementChild) a = a.firstElementChild; вернуть a}). append (this)), this}, wrapInner: function (a) {return r.isФункция (a)? This.each (function (b) {r (this) .wrapInner (a.call (this, b))}): this.each (function () {var b = r (this), c = b.contents (); c.length? c.wrapAll (a): b.append (a)})}, wrap: function (a) {var b = r.isFunction (a); вернуть this.each ( function (c) {r (this) .wrapAll (b? a.call (this, c): a)})}, развернуть: function (a) {вернуть this.parent (a) .not ("body") .each (функция () {г (это) .replaceWith (this.childNodes)}), это}}), r.expr.pseudos.hidden = функция (а) {возвращение! r.expr.pseudos.visible (а )}, r.expr.pseudos.visible = function (a) {return !! (a.offsetWidth || a.offsetHeight || a.getClientRects (). length)}, o.createHTMLDocument = function () {var a = d.implementation.createHTMLDocument (""). body; return a.innerHTML = "<form> </ form> <form> </ form>", 2 === a.childNodes.length} (), r. parseHTML = function (a, b, c) {if ("string"! = typeof a) return []; "boolean"== typeof b && (c = b, b =! 1); var e, f, g; вернуть b || (o.createHTMLDocument? (b = d.implementation.createHTMLDocument (""), e = b.createElement ( "база"), e.href = d.location.href, b.head.appendChild (е)): б = д), е = C.exec (а), г = с && [], F [б!? .createElement (е [1])] :( F = QA ([а], б, г), г && g.length && г (г) .remove (), r.merge ([], f.childNodes))}, г .offset = {setOffset: function (a, b, c) {var d, e, f, g, h, i, j, k = r.css (a, "position"), l = r (a), м = {}; "статические" === к && (a.style.position = "относительно"), ч = l.offset (), F = r.css (а, "верх"), I = r.css (а, "левый"), J = ( "абсолютный" === || к "фиксированным" === к) && (F + I) .indexOf ( "авто")> - 1, J (d = l.position (), г = d.top, е = d.left) :( г = parseFloat (е) || 0, е = parseFloat (я) || 0), r.isFunction (б) && (б = b.call (а, с, r.extend ({}, Л))), нуль! = b.top && (m.top = b.top-ч.top + g), null! = b.left && (m.left = b.left-h.left + e), «использование» в b? b.using.call (a, m): l.css (m) }}, r.fn.extend ({offset: function (a) {if (arguments.length) return void 0 === a? this: this.each (function (b) {r.offset.setOffset (this, a, b)}); var b, c, d, e, f = this [0]; if (f) возвращает f.getClientRects (). length? (d = f.getBoundingClientRect (), b = f.ownerDocument , с = b.documentElement, е = b.defaultView, {верх: d.top + e.pageYOffset-c.clientTop, слева: d.left + e.pageXOffset-c.clientLeft}): {верх: 0, левый : 0}}, position: function () {if (this [0]) {var a, b, c = this [0], d = {top: 0, left: 0}; вернуть "fixed" === r.css (с, "позиция")? б = c.getBoundingClientRect () :( а = this.offsetParent (), б = this.offset (), В ([0], "HTML") || ( д = a.offset ()), г = {верх: d.top + r.css (а [0], "borderTopWidth", 0), слева: d.left + r.css (а [0], "borderLeftWidth", 0)}), {верх: b.top-d.top-r.css (с, "MarginTop",! 0), слева: b.left-d.left-r.css (c, "marginLeft",! 0)}}}, offsetParent: function () {вернуть this.map (function () {var a = this .offsetParent; while (a && "static" === r.css (a, "position")) a = a.offsetParent; вернуть a || ra})}}), r.each ({scrollLeft: "pageXOffset" , scrollTop: "pageYOffset"}, функция (a, b) {var c = "pageYOffset" === b; r.fn [a] = function (d) {вернуть T (this, функция (a, d, e) ) {var f; вернуть r.isWindow (a)? f = a: 9 === a.nodeType && (f = a.defaultView), void 0 === e? f? f [b]: a [d] : недействительный (е f.scrollTo (с f.pageXOffset:? е, с й:? f.pageYOffset): а [d] = е)}, а, д, arguments.length)}}), r.each (["top", "left"], function (a, b) {r.cssHooks [b] = Pa (o.pixelPosition, function (a, c) {if (c) возвращает c = Oa (a, b) ), Ma.test (с) г (а) .position () [Ь] + "ПВ": с})}), r.each ({высота: "высота", ширина: "ширина"}, функция (а, б) {г.каждая ({padding: "inner" + a, content: b, "": "external" + a}, функция (c, d) {r.fn [d] = функция (e, f) {var g = arguments .length && (c || "логическое"! = typeof e), h = c || (e ===! 0 || f ===! 0? "margin": "border"); вернуть T (this, function (b, c, e) {var f; return r.isWindow (b)? 0 === d.indexOf ("external")? b ["inner" + a]: b.document.documentElement ["client "+ а]: 9 === b.nodeType (F = b.documentElement, Math.max (b.body [" прокрутки "+ а], F [" прокрутки "+ а], b.body [" смещение "+ a], f [" offset "+ a], f [" client "+ a])): void 0 === e? r.css (b, c, h): r.style (b, c , e, h)}, b, g? e: void 0, g)}})}), r.fn.extend ({bind: function (a, b, c) {вернуть this.on (a, null , b, c)}, unbind: function (a, b) {вернуть this.off (a, null, b)}, делегат: function (a, b, c, d) {вернуть this.on (b, a , c, d)}, undelegate: function (a, b, c) {вернуть 1 === аргументы.Длина this.off (а, "**"): this.off (б, а || "**", с)}}), r.holdReady = функция (а) {а r.readyWait ++? г .ready (! 0)}, r.isArray = Array.isArray, r.parseJSON = JSON.parse, r.nodeName = B, "function" == typeof define && define.amd && define ("jquery", [], function () {return r}); var mb = a.jQuery, nb = a. $; return r.noConflict = function (b) {return a. $ === r && (a. $ = nb), b && a.jQuery == = г && (a.jQuery = Мб), г}, Ь || (a.jQuery = а $ = г.), г});JQuery === г && (a.jQuery = Мб), г}, Ь || (a.jQuery = а $ = г.), г});JQuery === г && (a.jQuery = Мб), г}, Ь || (a.jQuery = а $ = г.), г});